import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';
import { Upload, Info, Play, Pause, Eye, Code, Layers, Camera, StopCircle, RefreshCw } from 'lucide-react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

// --- Helper Functions for SHD-CCP Packet ---

const toBinary = (num, length) => {
    if (typeof num !== 'number' || isNaN(num)) {
        return '0'.padStart(length, '0');
    }
    return Math.floor(num).toString(2).padStart(length, '0');
};

const createShdCcpPacket = (r, g, b, a) => {
    const quatW = toBinary(r, 8);
    const quatX = toBinary(g, 8);
    const quatY = toBinary(b, 8);
    const quatZ = toBinary(a, 8);
    const compressedQuaternion = `${quatW}${quatX}${quatY}${quatZ}`;
    const structuralFormId = toBinary(r % 16, 4);
    const amplitudeId = toBinary(g % 8, 3);
    const reserved = toBinary(0, 1);
    const frequencyId = toBinary(b % 32, 5);
    const spinClassId = toBinary(a % 8, 3);
    const payloadScalingFactor = toBinary(Math.floor(((r + g + b) / 3) * (65535 / 255)), 16);
    return {
        compressedQuaternion,
        structuralFormId,
        amplitudeId,
        reserved,
        frequencyId,
        spinClassId,
        payloadScalingFactor,
        fullPacket: `${compressedQuaternion}${structuralFormId}${amplitudeId}${reserved}${frequencyId}${spinClassId}${payloadScalingFactor}`
    };
};

// --- React Components ---

const Tooltip = ({ text, children }) => (
    <div className="relative flex items-center group">
        {children}
        <div className="absolute left-full ml-4 w-48 px-2 py-1 bg-gray-800 border border-cyan-400/50 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 z-10">
            {text}
        </div>
    </div>
);

const PacketVisualizer = ({ packet }) => {
    if (!packet) return null;
    const fields = [
        { name: 'Quaternion (RGBA)', value: packet.compressedQuaternion, color: 'text-green-400', bits: 32, desc: 'W(R), X(G), Y(B), Z(A) components, 8 bits each.' },
        { name: 'Struct ID', value: packet.structuralFormId, color: 'text-cyan-400', bits: 4, desc: 'Maps to a pre-compiled computational kernel.' },
        { name: 'Amplitude ID', value: packet.amplitudeId, color: 'text-yellow-400', bits: 3, desc: 'Represents concept magnitude or importance.' },
        { name: 'Reserved', value: packet.reserved, color: 'text-gray-500', bits: 1, desc: 'Reserved for future use or parity.' },
        { name: 'Frequency ID', value: packet.frequencyId, color: 'text-purple-400', bits: 5, desc: 'Maps to GPU operational states.' },
        { name: 'Spin Class ID', value: packet.spinClassId, color: 'text-orange-400', bits: 3, desc: 'Maps to a rotational behavior or state update rule.' },
        { name: 'Payload Scale', value: packet.payloadScalingFactor, color: 'text-red-400', bits: 16, desc: 'A universal scaling factor for the payload.' },
    ];
    return (
        <div className="bg-gray-900/50 p-4 rounded-lg border border-gray-700 font-mono text-xs">
            <h3 className="text-lg font-sans text-cyan-300 mb-3">SHD-CCP Packet (64-bit)</h3>
            <div className="break-all leading-relaxed">{fields.map(f => <span key={f.name} className={f.color}>{f.value}</span>)}</div>
            <div className="mt-4 space-y-2 font-sans">
                {fields.map(field => (
                    <div key={field.name} className="flex items-center justify-between">
                        <Tooltip text={field.desc}>
                            <div className="flex items-center">
                                <div className={`w-3 h-3 rounded-full mr-2 ${field.color.replace('text-', 'bg-').replace('-400', '-500')}`}></div>
                                <span className="text-gray-300">{field.name} ({field.bits}b)</span>
                            </div>
                        </Tooltip>
                        <span className={`${field.color} font-mono`}>{parseInt(field.value, 2)}</span>
                    </div>
                ))}
            </div>
        </div>
    );
};

const QFTSimulator = ({ pixelHistory, currentFrame }) => {
    const canvasRef = useRef(null);
    useEffect(() => {
        if (!pixelHistory || pixelHistory.length === 0 || !canvasRef.current) return;
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const { width, height } = canvas;
        const signal = pixelHistory.map(p => (Math.sin(p.r / 255 * Math.PI * 2) + Math.cos(p.g / 255 * Math.PI) - Math.sin(p.b / 255 * Math.PI)) / 3);
        ctx.clearRect(0, 0, width, height);
        const gradient = ctx.createLinearGradient(0, 0, width, 0);
        gradient.addColorStop(0, '#00ffff');
        gradient.addColorStop(0.5, '#ff00ff');
        gradient.addColorStop(1, '#ffff00');
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 2;
        ctx.shadowColor = 'rgba(0, 255, 255, 0.7)';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(0, height / 2);
        signal.forEach((val, i) => {
            const x = (i / (signal.length - 1)) * width;
            const y = height / 2 + val * (height / 2.5);
            ctx.lineTo(x, y);
        });
        ctx.stroke();
        ctx.shadowColor = 'transparent';
        if (currentFrame >= 0 && currentFrame < signal.length) {
            const markerX = (currentFrame / (signal.length - 1)) * width;
            ctx.beginPath();
            ctx.moveTo(markerX, 0);
            ctx.lineTo(markerX, height);
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }, [pixelHistory, currentFrame]);
    return (
        <div className="bg-gray-900/50 p-4 rounded-lg border border-gray-700">
            <h3 className="text-lg text-cyan-300 mb-3">Simulated QFT Waveform</h3>
            <canvas ref={canvasRef} width="400" height="150" className="bg-black rounded-md w-full"></canvas>
            <p className="text-xs text-gray-400 mt-2">Visual representation of the selected pixel's data over time.</p>
        </div>
    );
};

const HolographicViewer = ({ videoFrames, currentFrame, dimensions, trailLength, isLive }) => {
    const mountRef = useRef(null);
    const mainPointsRef = useRef(null);
    const trailPointsRef = useRef([]);
    const rendererRef = useRef(null);
    const sceneRef = useRef(null);

    useEffect(() => {
        if (!mountRef.current || (!videoFrames.length && !isLive)) return;

        const { width, height } = dimensions;
        const scene = new THREE.Scene();
        sceneRef.current = scene;
        const camera = new THREE.PerspectiveCamera(75, mountRef.current.clientWidth / mountRef.current.clientHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        rendererRef.current = renderer;
        
        renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        mountRef.current.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const positions = new Float32Array(width * height * 3);
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 3;
                positions[i] = x - width / 2;
                positions[i + 1] = -y + height / 2;
                positions[i + 2] = 0;
            }
        }
        
        trailPointsRef.current.forEach(points => scene.remove(points));
        trailPointsRef.current = [];

        if (mainPointsRef.current) scene.remove(mainPointsRef.current);
        const mainGeometry = new THREE.BufferGeometry();
        mainGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        mainGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(width * height * 3), 3));
        const mainMaterial = new THREE.PointsMaterial({ size: 1.5, vertexColors: true, sizeAttenuation: true });
        mainPointsRef.current = new THREE.Points(mainGeometry, mainMaterial);
        scene.add(mainPointsRef.current);
        
        for (let i = 0; i < trailLength; i++) {
            const trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(width * height * 3), 3));
            
            const trailMaterial = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.5 - (i * (0.5 / trailLength))
            });

            const trailPoints = new THREE.Points(trailGeometry, trailMaterial);
            trailPoints.position.z = -(i + 1) * 3;
            trailPointsRef.current.push(trailPoints);
            scene.add(trailPoints);
        }

        camera.position.z = Math.max(width, height) / 1.5;

        let animationFrameId;
        const animate = () => {
            animationFrameId = requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        };
        animate();

        const handleResize = () => {
            if (!mountRef.current || !rendererRef.current) return;
            camera.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;
            camera.updateProjectionMatrix();
            rendererRef.current.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
        };
        window.addEventListener('resize', handleResize);

        return () => {
            cancelAnimationFrame(animationFrameId);
            window.removeEventListener('resize', handleResize);
            if (mountRef.current && rendererRef.current && rendererRef.current.domElement) {
                mountRef.current.removeChild(rendererRef.current.domElement);
            }
        };
    }, [dimensions, videoFrames.length, trailLength, isLive]);

    useEffect(() => {
        if (!videoFrames.length) return;

        if (mainPointsRef.current) {
            const frameData = videoFrames[currentFrame].data;
            const colors = mainPointsRef.current.geometry.attributes.color.array;
            for (let i = 0; i < frameData.length / 4; i++) {
                const colorIndex = i * 3;
                const dataIndex = i * 4;
                colors[colorIndex] = frameData[dataIndex] / 255;
                colors[colorIndex + 1] = frameData[dataIndex + 1] / 255;
                colors[colorIndex + 2] = frameData[dataIndex + 2] / 255;
            }
            mainPointsRef.current.geometry.attributes.color.needsUpdate = true;
        }

        trailPointsRef.current.forEach((trailPoints, index) => {
            const frameIndex = (currentFrame - (index + 1) + videoFrames.length) % videoFrames.length;
            if (!videoFrames[frameIndex]) return;
            const frameData = videoFrames[frameIndex].data;
            const colors = trailPoints.geometry.attributes.color.array;

            for (let i = 0; i < frameData.length / 4; i++) {
                const colorIndex = i * 3;
                const dataIndex = i * 4;
                colors[colorIndex] = frameData[dataIndex] / 255;
                colors[colorIndex + 1] = frameData[dataIndex + 1] / 255;
                colors[colorIndex + 2] = frameData[dataIndex + 2] / 255;
            }
            trailPoints.geometry.attributes.color.needsUpdate = true;
        });

    }, [currentFrame, videoFrames]);

    return <div ref={mountRef} className="w-full h-full bg-purple-950 rounded-lg" />;
};


export default function App() {
    const [videoSrc, setVideoSrc] = useState(null);
    const [videoFrames, setVideoFrames] = useState([]);
    const [currentFrame, setCurrentFrame] = useState(0);
    const [selectedPixel, setSelectedPixel] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [loadingProgress, setLoadingProgress] = useState("");
    const [isPlaying, setIsPlaying] = useState(false);
    const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
    const [activeView, setActiveView] = useState('inspector');
    const [trailLength, setTrailLength] = useState(12);
    const [isLive, setIsLive] = useState(false);

    const videoRef = useRef(null);
    const hiddenCanvasRef = useRef(null);
    const displayCanvasRef = useRef(null);
    const liveStreamRef = useRef(null);
    const liveAnimationRef = useRef(null);
    const fileInputRef = useRef(null);

    const stopLiveFeed = () => {
        if (liveStreamRef.current) {
            liveStreamRef.current.getTracks().forEach(track => track.stop());
        }
        if (liveAnimationRef.current) {
            cancelAnimationFrame(liveAnimationRef.current);
        }
        setIsLive(false);
        liveStreamRef.current = null;
    };

    const handleReset = () => {
        stopLiveFeed();
        
        setVideoSrc(null);
        setVideoFrames([]);
        setCurrentFrame(0);
        setSelectedPixel(null);
        setIsLoading(false);
        setLoadingProgress("");
        setIsPlaying(false);
        setDimensions({ width: 0, height: 0 });
        setActiveView('inspector');

        if(videoRef.current) {
            videoRef.current.srcObject = null;
            videoRef.current.src = "";
        }
        if (fileInputRef.current) {
            fileInputRef.current.value = "";
        }
    };

    const handleFileUpload = (event) => {
        const file = event.target.files[0];
        if (file) {
            handleReset(); // Reset state before loading new file
            const url = URL.createObjectURL(file);
            setVideoSrc(url);
        }
    };
    
    const processVideo = useCallback((w, h) => {
        if (!videoRef.current || !hiddenCanvasRef.current) return;
        
        const video = videoRef.current;
        const canvas = hiddenCanvasRef.current;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        setIsLoading(true);
        setLoadingProgress("Calculating frames...");

        const frameRate = 24;
        const duration = video.duration;
        const totalFrames = Math.floor(duration * frameRate);
        let framesProcessed = 0;
        const tempFrames = [];

        video.currentTime = 0;

        const onSeeked = () => {
            if (framesProcessed < totalFrames) {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                tempFrames.push(imageData);
                framesProcessed++;
                setLoadingProgress(`Processing video: Frame ${framesProcessed} of ${totalFrames}`);
                video.currentTime += 1 / frameRate;
            } else {
                setVideoFrames(tempFrames);
                setSelectedPixel({ x: Math.floor(w / 2), y: Math.floor(h / 2) });
                setIsLoading(false);
                setLoadingProgress("");
                video.removeEventListener('seeked', onSeeked);
            }
        };
        video.addEventListener('seeked', onSeeked);
    }, []);

    const startLiveFeed = async () => {
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            handleReset();
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                setIsLive(true);
                liveStreamRef.current = stream;
                videoRef.current.srcObject = stream;
                videoRef.current.play();

                videoRef.current.onloadedmetadata = () => {
                    const MAX_WIDTH = 480;
                    const scale = Math.min(1, MAX_WIDTH / videoRef.current.videoWidth);
                    const w = videoRef.current.videoWidth * scale;
                    const h = videoRef.current.videoHeight * scale;
                    setDimensions({ width: w, height: h });
                    if (hiddenCanvasRef.current) {
                        hiddenCanvasRef.current.width = w;
                        hiddenCanvasRef.current.height = h;
                    }
                    if (displayCanvasRef.current) {
                        displayCanvasRef.current.width = w;
                        displayCanvasRef.current.height = h;
                    }
                    setSelectedPixel({ x: Math.floor(w / 2), y: Math.floor(h / 2) });
                    captureLiveFrame();
                };

            } catch (err) {
                console.error("Error accessing webcam: ", err);
            }
        }
    };

    const captureLiveFrame = useCallback(() => {
        if (!videoRef.current || !hiddenCanvasRef.current || !liveStreamRef.current) return;
        
        const video = videoRef.current;
        const canvas = hiddenCanvasRef.current;
        const ctx = canvas.getContext('2d');

        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        setVideoFrames(prevFrames => {
            const newFrames = [...prevFrames, imageData];
            if (newFrames.length > trailLength + 20) {
                return newFrames.slice(newFrames.length - (trailLength + 20));
            }
            return newFrames;
        });
        setCurrentFrame(prev => prev + 1);

        liveAnimationRef.current = requestAnimationFrame(captureLiveFrame);

    }, [trailLength]);

    useEffect(() => {
        if (isLive) {
            liveAnimationRef.current = requestAnimationFrame(captureLiveFrame);
        }
        return () => {
            if (liveAnimationRef.current) {
                cancelAnimationFrame(liveAnimationRef.current);
            }
        };
    }, [isLive, captureLiveFrame]);


    useEffect(() => {
        if (videoSrc) {
            const video = videoRef.current;
            const onLoadedMetadata = () => {
                const MAX_WIDTH = 480;
                const scale = Math.min(1, MAX_WIDTH / video.videoWidth);
                const w = video.videoWidth * scale;
                const h = video.videoHeight * scale;
                setDimensions({ width: w, height: h });
                if (hiddenCanvasRef.current) { hiddenCanvasRef.current.width = w; hiddenCanvasRef.current.height = h; }
                if (displayCanvasRef.current) { displayCanvasRef.current.width = w; displayCanvasRef.current.height = h; }
                processVideo(w, h);
            };
            video.addEventListener('loadedmetadata', onLoadedMetadata);
            return () => { if (video) video.removeEventListener('loadedmetadata', onLoadedMetadata); };
        }
    }, [videoSrc, processVideo]);

    useEffect(() => {
        if (videoFrames.length > 0 && displayCanvasRef.current && activeView === 'inspector') {
            const frameIndex = isLive ? videoFrames.length - 1 : currentFrame;
            if (!videoFrames[frameIndex]) return;
            const ctx = displayCanvasRef.current.getContext('2d');
            ctx.putImageData(videoFrames[frameIndex], 0, 0);
        }
    }, [currentFrame, videoFrames, activeView, isLive]);

    useEffect(() => {
        let intervalId = null;
        if (isPlaying && !isLive && videoFrames.length > 0) {
            intervalId = setInterval(() => setCurrentFrame(prev => (prev + 1) % videoFrames.length), 1000 / 24);
        }
        return () => { if (intervalId) clearInterval(intervalId); };
    }, [isPlaying, videoFrames.length, isLive]);

    const handleCanvasMouseMove = (event) => {
        if (videoFrames.length === 0) return;
        const canvas = displayCanvasRef.current;
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor(event.clientX - rect.left);
        const y = Math.floor(event.clientY - rect.top);
        if (x >= 0 && x < dimensions.width && y >= 0 && y < dimensions.height) {
            setSelectedPixel({ x, y });
        }
    };
    
    const getPixelData = (pixel) => {
        if (!pixel || videoFrames.length === 0) return null;
        const frameIndex = isLive ? videoFrames.length - 1 : currentFrame;
        if (!videoFrames[frameIndex]) return null;
        const imageData = videoFrames[frameIndex].data;
        const i = (pixel.y * dimensions.width + pixel.x) * 4;
        return { r: imageData[i], g: imageData[i+1], b: imageData[i+2], a: imageData[i+3] };
    };

    const getPixelHistory = (pixel) => {
        if (!pixel || videoFrames.length === 0) return [];
        return videoFrames.map(frame => {
            const imageData = frame.data;
            const i = (pixel.y * dimensions.width + pixel.x) * 4;
            return { r: imageData[i], g: imageData[i+1], b: imageData[i+2], a: imageData[i+3] };
        });
    };

    const pixelData = getPixelData(selectedPixel);
    const packet = useMemo(() => pixelData ? createShdCcpPacket(pixelData.r, pixelData.g, pixelData.b, pixelData.a) : null, [pixelData]);
    const pixelHistory = useMemo(() => getPixelHistory(selectedPixel), [selectedPixel, videoFrames]);
    
    const displayFrameIndex = isLive ? videoFrames.length -1 : currentFrame;

    return (
        <div className="bg-gray-900 text-gray-200 min-h-screen font-sans p-4 sm:p-8 flex flex-col">
            <header className="text-center mb-6">
                <h1 className="text-3xl sm:text-4xl font-bold text-cyan-300 tracking-wider">Temporal SHD-CCP Stream Visualizer</h1>
                <p className="text-gray-400 mt-2 max-w-3xl mx-auto">Upload a video or start a live feed to visualize pixels as holographic data streams.</p>
            </header>

            <main className="flex-grow flex flex-col lg:flex-row gap-8">
                {/* Left Panel: Video and Controls */}
                <div className="lg:w-1/2 flex flex-col items-center justify-center gap-4 p-4 bg-black/30 rounded-xl border border-gray-700/50">
                    <div className="w-full flex-grow flex items-center justify-center relative bg-purple-950 rounded-lg">
                        {(videoFrames.length > 0 || isLive) ? (
                            activeView === 'inspector' ? (
                                <canvas ref={displayCanvasRef} onMouseMove={handleCanvasMouseMove} className="max-w-full max-h-full cursor-crosshair rounded-md" />
                            ) : (
                                <HolographicViewer videoFrames={videoFrames} currentFrame={displayFrameIndex} dimensions={dimensions} trailLength={trailLength} isLive={isLive} />
                            )
                        ) : (
                            <div className="flex flex-col gap-4 text-gray-400">
                                <label htmlFor="video-upload" className="cursor-pointer hover:text-cyan-400 transition-colors flex flex-col items-center gap-2">
                                    <Upload className="mx-auto h-12 w-12" />
                                    <span>Upload a Video File</span>
                                </label>
                                <input id="video-upload" ref={fileInputRef} type="file" accept="video/*" className="hidden" onChange={handleFileUpload} />
                                <span className="text-gray-600 self-center">OR</span>
                                 <button onClick={startLiveFeed} className="cursor-pointer hover:text-cyan-400 transition-colors flex flex-col items-center gap-2">
                                    <Camera className="mx-auto h-12 w-12" />
                                    <span>Start Live Feed</span>
                                </button>
                            </div>
                        )}
                        {isLoading && (
                            <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center rounded-lg">
                                <div className="w-16 h-16 border-4 border-cyan-400 border-t-transparent rounded-full animate-spin"></div>
                                <p className="mt-4 text-lg">{loadingProgress}</p>
                            </div>
                        )}
                    </div>
                    
                    {(videoFrames.length > 0 || isLive) && (
                        <div className="w-full p-2 flex flex-col gap-4">
                            {!isLive && videoFrames.length > 0 && (
                                <div className="flex items-center gap-4">
                                    <button onClick={() => setIsPlaying(!isPlaying)} className="p-2 bg-gray-700 hover:bg-cyan-600 rounded-full transition-colors">
                                        {isPlaying ? <Pause size={20}/> : <Play size={20}/>}
                                    </button>
                                    <span className="text-sm font-mono w-28 text-center">F: {currentFrame} / {videoFrames.length - 1}</span>
                                    <input type="range" min="0" max={videoFrames.length - 1} value={currentFrame} onChange={(e) => setCurrentFrame(Number(e.target.value))} className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-thumb" />
                                </div>
                            )}
                            {activeView === 'holographic' && (
                                <div className="flex items-center gap-2 px-2">
                                    <Layers size={16} className="text-cyan-400" />
                                    <span className="text-sm font-mono w-28 text-center">Trail: {trailLength}</span>
                                    <input id="trail-slider" type="range" min="0" max="30" value={trailLength} onChange={(e) => setTrailLength(Number(e.target.value))} className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-thumb" />
                                </div>
                            )}
                             <div className="flex justify-center gap-2 flex-wrap">
                                <button onClick={() => setActiveView('inspector')} className={`flex items-center gap-2 px-4 py-2 text-sm rounded-md transition-colors ${activeView === 'inspector' ? 'bg-cyan-600 text-white' : 'bg-gray-700 hover:bg-gray-600'}`}>
                                    <Code size={16} /> Inspector
                                </button>
                                <button onClick={() => setActiveView('holographic')} className={`flex items-center gap-2 px-4 py-2 text-sm rounded-md transition-colors ${activeView === 'holographic' ? 'bg-cyan-600 text-white' : 'bg-gray-700 hover:bg-gray-600'}`}>
                                    <Eye size={16} /> Holographic Viewer
                                </button>
                                {isLive && (
                                     <button onClick={stopLiveFeed} className="flex items-center gap-2 px-4 py-2 text-sm rounded-md transition-colors bg-red-600 hover:bg-red-500 text-white">
                                        <StopCircle size={16} /> Stop Feed
                                    </button>
                                )}
                                <button onClick={handleReset} className="flex items-center gap-2 px-4 py-2 text-sm rounded-md transition-colors bg-amber-600 hover:bg-amber-500 text-white">
                                    <RefreshCw size={16} /> Reset
                                </button>
                            </div>
                        </div>
                    )}
                </div>

                {/* Right Panel: Data Visualization */}
                <div className="lg:w-1/2 flex flex-col gap-4 p-4 bg-black/30 rounded-xl border border-gray-700/50">
                    {(videoFrames.length > 0 || isLive) && selectedPixel ? (
                        <div className="space-y-4">
                            <div className="text-center bg-gray-900/50 p-3 rounded-lg border border-gray-700">
                                <h2 className="text-xl text-yellow-300">Pixel Data @ ({selectedPixel.x}, {selectedPixel.y})</h2>
                                {pixelData && <p className="font-mono text-lg mt-1"><span className="text-red-500">R:{pixelData.r}</span> <span className="text-green-500">G:{pixelData.g}</span> <span className="text-blue-500">B:{pixelData.b}</span> <span className="text-gray-400">A:{pixelData.a}</span></p>}
                            </div>
                            <PacketVisualizer packet={packet} />
                            <QFTSimulator pixelHistory={pixelHistory} currentFrame={displayFrameIndex} />
                        </div>
                    ) : (
                        <div className="flex-grow flex items-center justify-center text-center text-gray-500">
                            <div>
                                <Info className="mx-auto h-12 w-12" />
                                <p className="mt-2">Upload a video or start a live feed.</p>
                            </div>
                        </div>
                    )}
                </div>
            </main>
            <video ref={videoRef} src={videoSrc} className="hidden" muted playsInline />
            <canvas ref={hiddenCanvasRef} className="hidden" />
            <style>{`.range-thumb::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:16px;height:16px;background:#22d3ee;cursor:pointer;border-radius:50%;box-shadow:0 0 5px #22d3ee;}.range-thumb::-moz-range-thumb{width:16px;height:16px;background:#22d3ee;cursor:pointer;border-radius:50%;border:none;box-shadow:0 0 5px #22d3ee;}`}</style>
        </div>
    );
}

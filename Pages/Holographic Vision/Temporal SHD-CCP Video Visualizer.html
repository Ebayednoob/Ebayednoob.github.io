<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temporal SHD-CCP Stream Visualizer</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons for UI icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        /* Custom styles for the range slider thumb */
        .range-thumb::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #22d3ee;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 5px #22d3ee;
            margin-top: -6px; /* Center thumb on track */
        }
        .range-thumb::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #22d3ee;
            cursor: pointer;
            border: none;
            border-radius: 50%;
            box-shadow: 0 0 5px #22d3ee;
        }
        /* Custom tooltip styles */
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 192px; /* w-48 */
            background-color: #1f2937; /* bg-gray-800 */
            color: #fff;
            text-align: left;
            border-radius: 0.375rem; /* rounded-md */
            padding: 4px 8px; /* px-2 py-1 */
            position: absolute;
            z-index: 10;
            left: 105%;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.75rem; /* text-xs */
            border: 1px solid rgba(34, 211, 238, 0.5); /* border-cyan-400/50 */
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 min-h-screen font-sans">

    <div class="p-4 sm:p-8 flex flex-col h-screen">
        <header class="text-center mb-6">
            <h1 class="text-3xl sm:text-4xl font-bold text-cyan-300 tracking-wider">Temporal SHD-CCP Stream Visualizer</h1>
            <p class="text-gray-400 mt-2 max-w-3xl mx-auto">Upload a video or start a live feed to visualize pixels as holographic data streams.</p>
        </header>

        <main class="flex-grow flex flex-col lg:flex-row gap-8 min-h-0">
            <!-- Left Panel: Visualizer and Controls -->
            <div class="lg:w-1/2 flex flex-col gap-4 p-4 bg-black/30 rounded-xl border border-gray-700/50">
                <div id="visualizer-container" class="w-full flex-grow relative bg-purple-950 rounded-lg min-h-[300px]">
                    <!-- This is where the canvas or holographic viewer will be mounted -->
                    <div id="initial-view" class="w-full h-full flex flex-col items-center justify-center gap-4 text-gray-400">
                        <label for="video-upload-input" class="cursor-pointer hover:text-cyan-400 transition-colors flex flex-col items-center gap-2">
                            <i data-lucide="upload" class="mx-auto h-12 w-12"></i>
                            <span>Upload a Video File</span>
                        </label>
                        <input id="video-upload-input" type="file" accept="video/*" class="hidden">
                        <span class="text-gray-600 self-center">OR</span>
                        <button id="start-live-feed-btn" class="cursor-pointer hover:text-cyan-400 transition-colors flex flex-col items-center gap-2">
                            <i data-lucide="camera" class="mx-auto h-12 w-12"></i>
                            <span>Start Live Feed</span>
                        </button>
                    </div>
                    <div id="loading-overlay" class="hidden absolute inset-0 bg-black/80 flex-col items-center justify-center rounded-lg">
                        <div class="w-16 h-16 border-4 border-cyan-400 border-t-transparent rounded-full animate-spin"></div>
                        <p id="loading-progress-text" class="mt-4 text-lg"></p>
                    </div>
                </div>
                
                <div id="controls-panel" class="hidden w-full p-2 flex-col gap-4">
                    <!-- Playback Controls -->
                    <div id="playback-controls" class="flex items-center gap-4">
                        <button id="play-pause-btn" class="p-2 bg-gray-700 hover:bg-cyan-600 rounded-full transition-colors">
                            <i data-lucide="play" style="width: 20px; height: 20px;"></i>
                        </button>
                        <span id="frame-counter" class="text-sm font-mono w-28 text-center">F: 0 / 0</span>
                        <input id="frame-slider" type="range" min="0" max="0" value="0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-thumb">
                    </div>
                    <!-- Holographic Controls -->
                    <div id="holographic-controls-container" class="hidden flex-col gap-2">
                         <div class="flex items-center gap-2 px-2">
                            <i data-lucide="layers" class="text-cyan-400" style="width: 16px; height: 16px;"></i>
                            <span id="trail-label" class="text-sm font-mono w-28 text-center">Trail: 12</span>
                            <input id="trail-slider" type="range" min="0" max="30" value="12" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-thumb">
                        </div>
                        <div id="temporal-link-controls" class="hidden flex-col gap-2">
                            <div class="flex items-center gap-2 px-2">
                                <span id="similarity-label" class="text-sm font-mono w-28 text-center">Similarity: 5%</span>
                                <input id="similarity-slider" type="range" min="0" max="25" value="5" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-thumb">
                            </div>
                            <div class="flex items-center gap-2 px-2">
                                <span id="link-opacity-label" class="text-sm font-mono w-28 text-center">Link Opacity: 10%</span>
                                <input id="link-opacity-slider" type="range" min="0" max="100" value="90" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-thumb">
                            </div>
                        </div>
                    </div>
                    <!-- Main Action Buttons -->
                    <div class="flex justify-center gap-2 flex-wrap">
                        <button id="inspector-view-btn" class="flex items-center gap-2 px-4 py-2 text-sm rounded-md transition-colors bg-cyan-600 text-white">
                            <i data-lucide="code" style="width: 16px; height: 16px;"></i> Inspector
                        </button>
                        <button id="holographic-view-btn" class="flex items-center gap-2 px-4 py-2 text-sm rounded-md transition-colors bg-gray-700 hover:bg-gray-600">
                            <i data-lucide="eye" style="width: 16px; height: 16px;"></i> Holographic
                        </button>
                        <div id="depth-link-toggle-container" class="hidden items-center gap-2 px-4 py-2 text-sm rounded-md bg-gray-700">
                            <span class="text-gray-300">Depth Link</span>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="depth-link-checkbox" class="sr-only peer">
                                <div class="w-11 h-6 bg-gray-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-cyan-600"></div>
                            </label>
                        </div>
                        <button id="stop-feed-btn" class="hidden items-center gap-2 px-4 py-2 text-sm rounded-md transition-colors bg-red-600 hover:bg-red-500 text-white">
                            <i data-lucide="stop-circle" style="width: 16px; height: 16px;"></i> Stop Feed
                        </button>
                        <button id="reset-btn" class="flex items-center gap-2 px-4 py-2 text-sm rounded-md transition-colors bg-amber-600 hover:bg-amber-500 text-white">
                            <i data-lucide="refresh-cw" style="width: 16px; height: 16px;"></i> Reset
                        </button>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Data Inspector -->
            <div class="lg:w-1/2 flex flex-col gap-4 p-4 bg-black/30 rounded-xl border border-gray-700/50">
                <div id="data-inspector-panel" class="flex-grow flex items-center justify-center text-center text-gray-500">
                    <div>
                        <i data-lucide="info" class="mx-auto h-12 w-12"></i>
                        <p class="mt-2">Upload a video or start a live feed.</p>
                    </div>
                </div>
            </div>
        </main>

        <!-- Hidden elements for processing -->
        <video id="source-video" class="hidden" muted playsInline></video>
        <canvas id="hidden-canvas" class="hidden"></canvas>
    </div>

    <script type="module">
        // --- DOM Element References ---
        const DOMElements = {
            // Views & Overlays
            initialView: document.getElementById('initial-view'),
            loadingOverlay: document.getElementById('loading-overlay'),
            loadingProgressText: document.getElementById('loading-progress-text'),
            visualizerContainer: document.getElementById('visualizer-container'),
            dataInspectorPanel: document.getElementById('data-inspector-panel'),
            controlsPanel: document.getElementById('controls-panel'),
            
            // Buttons
            uploadInput: document.getElementById('video-upload-input'),
            startLiveFeedBtn: document.getElementById('start-live-feed-btn'),
            playPauseBtn: document.getElementById('play-pause-btn'),
            stopFeedBtn: document.getElementById('stop-feed-btn'),
            resetBtn: document.getElementById('reset-btn'),
            inspectorViewBtn: document.getElementById('inspector-view-btn'),
            holographicViewBtn: document.getElementById('holographic-view-btn'),

            // Controls
            playbackControls: document.getElementById('playback-controls'),
            frameSlider: document.getElementById('frame-slider'),
            frameCounter: document.getElementById('frame-counter'),
            holographicControlsContainer: document.getElementById('holographic-controls-container'),
            trailSlider: document.getElementById('trail-slider'),
            trailLabel: document.getElementById('trail-label'),
            depthLinkToggleContainer: document.getElementById('depth-link-toggle-container'),
            depthLinkCheckbox: document.getElementById('depth-link-checkbox'),
            temporalLinkControls: document.getElementById('temporal-link-controls'),
            similaritySlider: document.getElementById('similarity-slider'),
            similarityLabel: document.getElementById('similarity-label'),
            linkOpacitySlider: document.getElementById('link-opacity-slider'),
            linkOpacityLabel: document.getElementById('link-opacity-label'),

            // Canvases & Video
            sourceVideo: document.getElementById('source-video'),
            hiddenCanvas: document.getElementById('hidden-canvas'),
        };

        // --- Application State ---
        let state = {
            videoSrc: null,
            videoFrames: [],
            currentFrame: 0,
            selectedPixel: null,
            isLoading: false,
            isPlaying: false,
            dimensions: { width: 0, height: 0 },
            activeView: 'inspector', // 'inspector' or 'holographic'
            trailLength: 12,
            isLive: false,
            isTemporalLinkingEnabled: false,
            similarityTolerance: 5,
            linkOpacity: 90,
            liveStreamRef: null,
            liveAnimationRef: null,
            displayCanvas: null,
            holographicMount: null,
        };

        // --- Three.js State ---
        let threeState = {
            scene: null,
            camera: null,
            renderer: null,
            controls: null,
            frameGroups: [],
            animationFrameId: null,
        };

        // --- Helper Functions for SHD-CCP Packet ---
        const toBinary = (num, length) => {
            if (typeof num !== 'number' || isNaN(num)) return '0'.padStart(length, '0');
            return Math.floor(num).toString(2).padStart(length, '0');
        };

        const createPixelPacket = (pixel) => {
            if (!pixel) return null;
            const { r, g, b, a } = pixel;
            const quatW = toBinary(r, 8);
            const quatX = toBinary(g, 8);
            const quatY = toBinary(b, 8);
            const quatZ = toBinary(a, 8);
            const compressedQuaternion = `${quatW}${quatX}${quatY}${quatZ}`;
            const structuralFormId = toBinary(r % 8, 4);
            const amplitudeId = toBinary(g % 8, 3);
            const reserved = toBinary(0, 1);
            const frequencyId = toBinary(b % 32, 5);
            const spinClassId = toBinary(a % 8, 3);
            const payloadScalingFactor = toBinary(Math.floor(((r + g + b) / 3) * (65535 / 255)), 16);

            return { type: 'pixel', compressedQuaternion, structuralFormId, amplitudeId, reserved, frequencyId, spinClassId, payloadScalingFactor, pixel };
        };

        // --- UI Update Functions ---
        
        function updatePacketVisualizer(packet) {
            if (!packet) return '';
            const fields = [
                { name: 'Quaternion (RGBA)', value: packet.compressedQuaternion, color: 'text-green-400', bits: 32, desc: 'W(R), X(G), Y(B), Z(A) components, 8 bits each.' },
                { name: 'Struct ID', value: packet.structuralFormId, color: 'text-cyan-400', bits: 4, desc: 'Maps to a pre-compiled computational kernel.' },
                { name: 'Amplitude ID', value: packet.amplitudeId, color: 'text-yellow-400', bits: 3, desc: 'Represents concept magnitude or importance.' },
                { name: 'Reserved', value: packet.reserved, color: 'text-gray-500', bits: 1, desc: 'Reserved for future use.' },
                { name: 'Frequency ID', value: packet.frequencyId, color: 'text-purple-400', bits: 5, desc: 'Maps to GPU operational states.' },
                { name: 'Spin Class ID', value: packet.spinClassId, color: 'text-orange-400', bits: 3, desc: 'Maps to a rotational behavior or state update rule.' },
                { name: 'Payload Scale', value: packet.payloadScalingFactor, color: 'text-red-400', bits: 16, desc: 'A universal scaling factor for the payload.' },
            ];
            
            const binaryString = fields.map(f => `<span class="${f.color}">${f.value}</span>`).join('');
            const detailsHtml = fields.map(field => `
                <div class="flex items-center justify-between">
                    <div class="tooltip flex items-center">
                        <div class="w-3 h-3 rounded-full mr-2 ${field.color.replace('text-', 'bg-').replace('-400', '-500')}"></div>
                        <span class="text-gray-300">${field.name} (${field.bits}b)</span>
                        <span class="tooltiptext">${field.desc}</span>
                    </div>
                    <span class="${field.color} font-mono">${parseInt(field.value, 2)}</span>
                </div>
            `).join('');

            return `
                <div class="bg-gray-900/50 p-4 rounded-lg border border-gray-700 font-mono text-xs">
                    <h3 class="text-lg font-sans text-cyan-300 mb-3">Pixel Packet</h3>
                    <div class="break-all leading-relaxed">${binaryString}</div>
                    <div class="mt-4 space-y-2 font-sans">${detailsHtml}</div>
                </div>`;
        }
        
        function updateQFTSimulator(pixelHistory, currentFrame) {
            const container = document.createElement('div');
            container.className = "bg-gray-900/50 p-4 rounded-lg border border-gray-700";
            container.innerHTML = `
                <h3 class="text-lg text-cyan-300 mb-3">Simulated QFT Waveform</h3>
                <canvas width="400" height="150" class="bg-black rounded-md w-full"></canvas>
                <p class="text-xs text-gray-400 mt-2">Visual representation of the selected pixel's data over time.</p>
            `;

            const canvas = container.querySelector('canvas');
            if (!pixelHistory || pixelHistory.length === 0) return container;
            
            const ctx = canvas.getContext('2d');
            const { width, height } = canvas;
            const signal = pixelHistory.map(p => p ? (Math.sin(p.r / 255 * Math.PI * 2) + Math.cos(p.g / 255 * Math.PI) - Math.sin(p.b / 255 * Math.PI)) / 3 : 0);
            
            ctx.clearRect(0, 0, width, height);
            const gradient = ctx.createLinearGradient(0, 0, width, 0);
            gradient.addColorStop(0, '#00ffff');
            gradient.addColorStop(0.5, '#ff00ff');
            gradient.addColorStop(1, '#ffff00');
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 2;
            ctx.shadowColor = 'rgba(0, 255, 255, 0.7)';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            signal.forEach((val, i) => {
                const x = (i / (signal.length - 1)) * width;
                const y = height / 2 + val * (height / 2.5);
                ctx.lineTo(x, y);
            });
            ctx.stroke();
            ctx.shadowColor = 'transparent';

            const frameIdx = state.isLive ? signal.length - 1 : currentFrame;
            if (frameIdx >= 0 && frameIdx < signal.length) {
                const markerX = (frameIdx / (signal.length - 1)) * width;
                ctx.beginPath();
                ctx.moveTo(markerX, 0);
                ctx.lineTo(markerX, height);
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            return container;
        }

        function updateDataInspector() {
            if ((state.videoFrames.length > 0 || state.isLive) && state.selectedPixel) {
                const displayFrameIndex = state.isLive ? state.videoFrames.length - 1 : state.currentFrame;
                const pixelData = getPixelData(state.selectedPixel, displayFrameIndex);
                const packet = createPixelPacket(pixelData);
                const pixelHistory = getPixelHistory(state.selectedPixel);

                const pixelDataHtml = pixelData ? `<p class="font-mono text-lg mt-1"><span class="text-red-500">R:${pixelData.r}</span> <span class="text-green-500">G:${pixelData.g}</span> <span class="text-blue-500">B:${pixelData.b}</span> <span class="text-gray-400">A:${pixelData.a}</span></p>` : '';

                const inspectorContent = document.createElement('div');
                inspectorContent.className = 'space-y-4 w-full';
                inspectorContent.innerHTML = `
                    <div class="text-center bg-gray-900/50 p-3 rounded-lg border border-gray-700">
                        <h2 class="text-xl text-yellow-300">Pixel Data @ (${state.selectedPixel.x}, ${state.selectedPixel.y})</h2>
                        ${pixelDataHtml}
                    </div>
                `;
                inspectorContent.innerHTML += updatePacketVisualizer(packet);
                inspectorContent.appendChild(updateQFTSimulator(pixelHistory, state.currentFrame));
                
                DOMElements.dataInspectorPanel.innerHTML = '';
                DOMElements.dataInspectorPanel.appendChild(inspectorContent);
            } else {
                 DOMElements.dataInspectorPanel.innerHTML = `
                    <div class="flex-grow flex items-center justify-center text-center text-gray-500">
                        <div>
                            <i data-lucide="info" class="mx-auto h-12 w-12"></i>
                            <p class="mt-2">Upload a video or start a live feed.</p>
                        </div>
                    </div>`;
                lucide.createIcons();
            }
        }
        
        function updateMainView() {
            const hasMedia = state.videoFrames.length > 0 || state.isLive;
            DOMElements.initialView.style.display = hasMedia ? 'none' : 'flex';
            DOMElements.controlsPanel.style.display = hasMedia ? 'flex' : 'none';
            
            if (hasMedia) {
                if (state.activeView === 'inspector') {
                    if (!state.displayCanvas) {
                        state.displayCanvas = document.createElement('canvas');
                        state.displayCanvas.className = "max-w-full max-h-full cursor-crosshair rounded-md";
                        state.displayCanvas.addEventListener('mousemove', handleCanvasMouseMove);
                    }
                    state.displayCanvas.width = state.dimensions.width;
                    state.displayCanvas.height = state.dimensions.height;
                    DOMElements.visualizerContainer.innerHTML = '';
                    DOMElements.visualizerContainer.appendChild(state.displayCanvas);
                    if (state.holographicMount) state.holographicMount.style.display = 'none';
                    state.displayCanvas.style.display = 'block';
                    drawDisplayFrame();
                } else { // Holographic view
                    if (state.displayCanvas) state.displayCanvas.style.display = 'none';
                    if (!state.holographicMount) {
                        state.holographicMount = document.createElement('div');
                        state.holographicMount.className = "w-full h-full bg-purple-950 rounded-lg";
                        DOMElements.visualizerContainer.appendChild(state.holographicMount);
                        initHolographicViewer();
                    }
                    state.holographicMount.style.display = 'block';
                    updateHolographicView();
                }
            } else {
                 DOMElements.visualizerContainer.innerHTML = '';
                 DOMElements.visualizerContainer.appendChild(DOMElements.initialView);
            }
            updateControlsVisibility();
            updateDataInspector();
        }

        function updateControlsVisibility() {
            DOMElements.playbackControls.style.display = !state.isLive && state.videoFrames.length > 0 ? 'flex' : 'none';
            DOMElements.stopFeedBtn.style.display = state.isLive ? 'flex' : 'none';
            DOMElements.holographicControlsContainer.style.display = state.activeView === 'holographic' ? 'flex' : 'none';
            DOMElements.depthLinkToggleContainer.style.display = state.activeView === 'holographic' ? 'flex' : 'none';
            DOMElements.temporalLinkControls.style.display = state.isTemporalLinkingEnabled ? 'flex' : 'none';
        }

        function drawDisplayFrame() {
            if (!state.displayCanvas || state.videoFrames.length === 0 || state.activeView !== 'inspector') return;
            const displayFrameIndex = state.isLive ? state.videoFrames.length - 1 : state.currentFrame;
            if (!state.videoFrames[displayFrameIndex]) return;

            const ctx = state.displayCanvas.getContext('2d');
            ctx.putImageData(state.videoFrames[displayFrameIndex], 0, 0);
        }

        // --- Data Logic ---
        function getPixelData(pixel, frameIndex) {
            if (!pixel || state.videoFrames.length === 0 || !state.videoFrames[frameIndex]) return null;
            const imageData = state.videoFrames[frameIndex].data;
            const i = (pixel.y * state.dimensions.width + pixel.x) * 4;
            if (i >= imageData.length) return null;
            return { r: imageData[i], g: imageData[i+1], b: imageData[i+2], a: imageData[i+3] };
        }

        function getPixelHistory(pixel) {
            if (!pixel || state.videoFrames.length === 0) return [];
            return state.videoFrames.map((frame, i) => getPixelData(pixel, i));
        }

        // --- Event Handlers ---
        function handleReset() {
            stopLiveFeed();
            state.videoSrc = null;
            state.videoFrames = [];
            state.currentFrame = 0;
            state.selectedPixel = null;
            state.isLoading = false;
            state.isPlaying = false;
            state.dimensions = { width: 0, height: 0 };
            state.activeView = 'inspector';
            
            DOMElements.sourceVideo.srcObject = null;
            DOMElements.sourceVideo.src = "";
            DOMElements.uploadInput.value = "";
            DOMElements.loadingOverlay.classList.add('hidden');

            if (state.displayCanvas) state.displayCanvas.remove();
            state.displayCanvas = null;
            if (state.holographicMount) {
                destroyHolographicViewer();
                state.holographicMount = null;
            }
            
            updateMainView();
            lucide.createIcons();
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                handleReset();
                const url = URL.createObjectURL(file);
                state.videoSrc = url;
                DOMElements.sourceVideo.src = url;
            }
        }

        async function startLiveFeed() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                handleReset();
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: 640 } } });
                    state.isLive = true;
                    state.liveStreamRef = stream;
                    DOMElements.sourceVideo.srcObject = stream;
                    await DOMElements.sourceVideo.play();
                } catch (err) {
                    console.error("Error accessing webcam: ", err);
                    alert("Could not access webcam. Please check permissions.");
                    handleReset();
                }
            }
        }

        function stopLiveFeed() {
            if (state.liveStreamRef) {
                state.liveStreamRef.getTracks().forEach(track => track.stop());
            }
            if (state.liveAnimationRef) {
                cancelAnimationFrame(state.liveAnimationRef);
            }
            state.isLive = false;
            state.liveStreamRef = null;
            state.liveAnimationRef = null;
            updateControlsVisibility();
        }

        function handleVideoMetadataLoaded() {
            const video = DOMElements.sourceVideo;
            if (state.isLoading || state.videoFrames.length > 0) return;

            const MAX_WIDTH = 480;
            const scale = Math.min(1, MAX_WIDTH / video.videoWidth);
            const w = Math.floor(video.videoWidth * scale);
            const h = Math.floor(video.videoHeight * scale);
            
            state.dimensions = { width: w, height: h };
            DOMElements.hiddenCanvas.width = w;
            DOMElements.hiddenCanvas.height = h;

            if (state.isLive) {
                state.selectedPixel = { x: Math.floor(w / 2), y: Math.floor(h / 2) };
                updateMainView();
                captureLiveFrame();
            } else {
                processVideo();
            }
        }

        function processVideo() {
            const video = DOMElements.sourceVideo;
            const canvas = DOMElements.hiddenCanvas;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            state.isLoading = true;
            DOMElements.loadingOverlay.classList.remove('hidden');
            DOMElements.loadingProgressText.textContent = "Calculating frames...";

            const frameRate = 24;
            const duration = video.duration;

            if (!isFinite(duration) || duration <= 0) {
                console.error("Video has invalid duration:", duration);
                DOMElements.loadingProgressText.textContent = "Error: Cannot process this video.";
                setTimeout(handleReset, 3000);
                return;
            }
            
            const totalFrames = Math.floor(duration * frameRate);
            let framesProcessed = 0;
            const tempFrames = [];

            const onSeekedHandler = () => {
                // Draw the frame now that seeking is complete
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                tempFrames.push(imageData);
                framesProcessed++;
                DOMElements.loadingProgressText.textContent = `Processing video: Frame ${framesProcessed} of ${totalFrames}`;

                if (framesProcessed < totalFrames) {
                    // Seek to the next frame
                    video.currentTime += (1 / frameRate);
                } else {
                    // All frames processed, finish up
                    video.removeEventListener('seeked', onSeekedHandler);
                    state.videoFrames = tempFrames;
                    state.selectedPixel = { x: Math.floor(state.dimensions.width / 2), y: Math.floor(state.dimensions.height / 2) };
                    state.isLoading = false;
                    DOMElements.loadingOverlay.classList.add('hidden');
                    DOMElements.frameSlider.max = state.videoFrames.length - 1;
                    DOMElements.frameCounter.textContent = `F: 0 / ${state.videoFrames.length - 1}`;
                    updateMainView();
                }
            };
            
            video.addEventListener('seeked', onSeekedHandler);
            
            // Start the process by seeking to a time very close to 0.
            // This is more reliable for triggering the 'seeked' event than seeking to 0.
            video.currentTime = 0.0001;
        }

        function captureLiveFrame() {
            if (!state.isLive) return;
            const video = DOMElements.sourceVideo;
            const canvas = DOMElements.hiddenCanvas;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            const newFrames = [...state.videoFrames, imageData];
            // Keep the buffer from growing indefinitely
            state.videoFrames = newFrames.length > state.trailLength + 20 ? newFrames.slice(1) : newFrames;
            
            // In live mode, currentFrame always points to the latest frame
            state.currentFrame = state.videoFrames.length - 1;

            if (state.activeView === 'inspector') {
                drawDisplayFrame();
            } else {
                updateHolographicView();
            }
            updateDataInspector();

            state.liveAnimationRef = requestAnimationFrame(captureLiveFrame);
        }
        
        function handleCanvasMouseMove(event) {
            if (!state.displayCanvas) return;
            const rect = state.displayCanvas.getBoundingClientRect();
            const x = Math.floor(event.clientX - rect.left);
            const y = Math.floor(event.clientY - rect.top);
            if (x >= 0 && x < state.dimensions.width && y >= 0 && y < state.dimensions.height) {
                state.selectedPixel = { x, y };
                updateDataInspector();
            }
        }
        
        let playInterval = null;
        function handlePlayPause() {
            state.isPlaying = !state.isPlaying;
            DOMElements.playPauseBtn.innerHTML = state.isPlaying ? '<i data-lucide="pause" style="width: 20px; height: 20px;"></i>' : '<i data-lucide="play" style="width: 20px; height: 20px;"></i>';
            lucide.createIcons();
            
            if (state.isPlaying) {
                playInterval = setInterval(() => {
                    const nextFrame = (state.currentFrame + 1) % state.videoFrames.length;
                    state.currentFrame = nextFrame;
                    DOMElements.frameSlider.value = nextFrame;
                    DOMElements.frameCounter.textContent = `F: ${nextFrame} / ${state.videoFrames.length - 1}`;
                    drawDisplayFrame();
                    updateHolographicView();
                    updateDataInspector();
                }, 1000 / 24);
            } else {
                clearInterval(playInterval);
            }
        }

        // --- Holographic Viewer Logic ---
        function initHolographicViewer() {
            if (!state.holographicMount) return;
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, state.holographicMount.clientWidth / state.holographicMount.clientHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            
            renderer.setSize(state.holographicMount.clientWidth, state.holographicMount.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            state.holographicMount.appendChild(renderer.domElement);

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            threeState = { scene, camera, renderer, controls, frameGroups: [] };

            const animate = () => {
                threeState.animationFrameId = requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            };
            animate();

            const handleResize = () => {
                if (!state.holographicMount || !renderer.domElement) return;
                camera.aspect = state.holographicMount.clientWidth / state.holographicMount.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(state.holographicMount.clientWidth, state.holographicMount.clientHeight);
            };
            window.addEventListener('resize', handleResize);
            
            rebuildHolographicGeometry();
        }

        function destroyHolographicViewer() {
            if (threeState.animationFrameId) cancelAnimationFrame(threeState.animationFrameId);
            if (state.holographicMount && threeState.renderer) {
                state.holographicMount.removeChild(threeState.renderer.domElement);
            }
            threeState = { scene: null, camera: null, renderer: null, controls: null, frameGroups: [], animationFrameId: null };
        }

        function rebuildHolographicGeometry() {
            if (!threeState.scene || !state.dimensions.width) return;
            const { scene, camera } = threeState;
            const { width, height } = state.dimensions;

            threeState.frameGroups.forEach(group => scene.remove(group));
            threeState.frameGroups = [];

            for (let i = 0; i < state.trailLength + 1; i++) {
                const group = new THREE.Group();
                const pointsGeometry = new THREE.BufferGeometry();
                pointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(width * height * 3), 3));
                pointsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(new Float32Array(width * height * 3), 3));
                const pointsMaterial = new THREE.PointsMaterial({ size: 1.5, vertexColors: true, transparent: true, sizeAttenuation: true });
                const points = new THREE.Points(pointsGeometry, pointsMaterial);
                
                const linesGeometry = new THREE.BufferGeometry();
                linesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(width * height * 3 * 2), 3));
                linesGeometry.setAttribute('color', new THREE.Float32BufferAttribute(new Float32Array(width * height * 3 * 2), 3));
                const linesMaterial = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true });
                const lines = new THREE.LineSegments(linesGeometry, linesMaterial);

                group.add(points);
                group.add(lines);
                scene.add(group);
                threeState.frameGroups.push(group);
            }
            if (camera.position.z < 100) {
                camera.position.z = Math.max(width, height) / 1.5;
            }
        }

        function updateHolographicView() {
            if (state.activeView !== 'holographic' || !state.videoFrames.length || !threeState.frameGroups || threeState.frameGroups.length === 0) return;

            const { width, height } = state.dimensions;
            const COLOR_TOLERANCE = (state.similarityTolerance / 100) * 255;
            const currentDisplayFrame = state.isLive ? state.videoFrames.length - 1 : state.currentFrame;

            threeState.frameGroups.forEach((group, i) => {
                // Corrected frame index calculation for both live and pre-recorded
                const frameIndex = (currentDisplayFrame - i + state.videoFrames.length) % state.videoFrames.length;
                
                const frameData = state.videoFrames[frameIndex]?.data;
                if (!frameData) return;

                const isMainFrame = i === 0;
                group.position.z = -i * 5;
                
                const points = group.children[0];
                const lines = group.children[1];
                
                const pPos = points.geometry.attributes.position.array;
                const pCol = points.geometry.attributes.color.array;
                const lPos = lines.geometry.attributes.position.array;
                const lCol = lines.geometry.attributes.color.array;
                
                let pCount = 0;
                let lCount = 0;

                if (state.isTemporalLinkingEnabled && !isMainFrame) {
                    const prevFrameIndex = (frameIndex - 1 + state.videoFrames.length) % state.videoFrames.length;
                    const prevFrameData = state.videoFrames[prevFrameIndex]?.data;
                    if (!prevFrameData) return;

                    for (let pIdx = 0; pIdx < frameData.length / 4; pIdx++) {
                        const cIdx = pIdx * 4;
                        const r1 = frameData[cIdx], g1 = frameData[cIdx+1], b1 = frameData[cIdx+2];
                        const r2 = prevFrameData[cIdx], g2 = prevFrameData[cIdx+1], b2 = prevFrameData[cIdx+2];
                        
                        const isSimilar = Math.abs(r1 - r2) < COLOR_TOLERANCE && Math.abs(g1 - g2) < COLOR_TOLERANCE && Math.abs(b1 - b2) < COLOR_TOLERANCE;
                        
                        const x = (pIdx % width) - width / 2;
                        const y = -(Math.floor(pIdx / width)) + height / 2;
                        const color = new THREE.Color(r1 / 255, g1 / 255, b1 / 255);

                        if (isSimilar) {
                            lPos[lCount * 6] = x; lPos[lCount * 6 + 1] = y; lPos[lCount * 6 + 2] = 5;
                            lPos[lCount * 6 + 3] = x; lPos[lCount * 6 + 4] = y; lPos[lCount * 6 + 5] = 0;
                            lCol[lCount * 6] = color.r; lCol[lCount * 6 + 1] = color.g; lCol[lCount * 6 + 2] = color.b;
                            lCol[lCount * 6 + 3] = color.r; lCol[lCount * 6 + 4] = color.g; lCol[lCount * 6 + 5] = color.b;
                            lCount++;
                        } else {
                            pPos[pCount * 3] = x; pPos[pCount * 3 + 1] = y; pPos[pCount * 3 + 2] = 0;
                            pCol[pCount * 3] = color.r; pCol[pCount * 3 + 1] = color.g; pCol[pCount * 3 + 2] = color.b;
                            pCount++;
                        }
                    }
                } else {
                    for (let pIdx = 0; pIdx < frameData.length / 4; pIdx++) {
                        const cIdx = pIdx * 4;
                        pPos[pCount * 3] = (pIdx % width) - width / 2;
                        pPos[pCount * 3 + 1] = -(Math.floor(pIdx / width)) + height / 2;
                        pPos[pCount * 3 + 2] = 0;
                        pCol[pCount * 3] = frameData[cIdx]/255;
                        pCol[pCount * 3 + 1] = frameData[cIdx+1]/255;
                        pCol[pCount * 3 + 2] = frameData[cIdx+2]/255;
                        pCount++;
                    }
                }

                points.geometry.setDrawRange(0, pCount);
                points.material.opacity = isMainFrame ? 1.0 : 0.5 - (i * (0.5 / state.trailLength));
                points.geometry.attributes.position.needsUpdate = true;
                points.geometry.attributes.color.needsUpdate = true;

                lines.geometry.setDrawRange(0, lCount * 2);
                lines.material.opacity = 1 - (state.linkOpacity / 100);
                lines.geometry.attributes.position.needsUpdate = true;
                lines.geometry.attributes.color.needsUpdate = true;
            });
        }

        // --- Initial Setup ---
        function initialize() {
            // Main buttons
            DOMElements.uploadInput.addEventListener('change', handleFileUpload);
            DOMElements.startLiveFeedBtn.addEventListener('click', startLiveFeed);
            DOMElements.resetBtn.addEventListener('click', handleReset);
            DOMElements.stopFeedBtn.addEventListener('click', stopLiveFeed);

            // View switchers
            DOMElements.inspectorViewBtn.addEventListener('click', () => {
                state.activeView = 'inspector';
                DOMElements.inspectorViewBtn.classList.add('bg-cyan-600', 'text-white');
                DOMElements.inspectorViewBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                DOMElements.holographicViewBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                DOMElements.holographicViewBtn.classList.remove('bg-cyan-600', 'text-white');
                updateMainView();
            });
            DOMElements.holographicViewBtn.addEventListener('click', () => {
                state.activeView = 'holographic';
                DOMElements.holographicViewBtn.classList.add('bg-cyan-600', 'text-white');
                DOMElements.holographicViewBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                DOMElements.inspectorViewBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                DOMElements.inspectorViewBtn.classList.remove('bg-cyan-600', 'text-white');
                updateMainView();
            });

            // Playback controls
            DOMElements.playPauseBtn.addEventListener('click', handlePlayPause);
            DOMElements.frameSlider.addEventListener('input', (e) => {
                state.currentFrame = Number(e.target.value);
                DOMElements.frameCounter.textContent = `F: ${state.currentFrame} / ${state.videoFrames.length - 1}`;
                if (state.activeView === 'inspector') drawDisplayFrame();
                updateHolographicView();
                updateDataInspector();
            });

            // Holographic controls
            DOMElements.trailSlider.addEventListener('input', (e) => {
                state.trailLength = Number(e.target.value);
                DOMElements.trailLabel.textContent = `Trail: ${state.trailLength}`;
                rebuildHolographicGeometry(); // Rebuild to match new trail length
                updateHolographicView();
            });
            DOMElements.depthLinkCheckbox.addEventListener('change', (e) => {
                state.isTemporalLinkingEnabled = e.target.checked;
                updateControlsVisibility();
                updateHolographicView();
            });
            DOMElements.similaritySlider.addEventListener('input', (e) => {
                state.similarityTolerance = Number(e.target.value);
                DOMElements.similarityLabel.textContent = `Similarity: ${state.similarityTolerance}%`;
                updateHolographicView();
            });
            DOMElements.linkOpacitySlider.addEventListener('input', (e) => {
                state.linkOpacity = Number(e.target.value);
                DOMElements.linkOpacityLabel.textContent = `Link Opacity: ${100 - state.linkOpacity}%`;
                updateHolographicView();
            });
            
            // Video element listeners
            DOMElements.sourceVideo.addEventListener('loadedmetadata', handleVideoMetadataLoaded);
            // Use 'canplay' as a more reliable event for when processing can begin
            DOMElements.sourceVideo.addEventListener('canplay', handleVideoMetadataLoaded);

            lucide.createIcons();
        }

        // Run initialization on DOM load
        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>

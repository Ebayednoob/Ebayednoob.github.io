<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floating Point Numbers Tutorial</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the animation and interactive elements */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        @keyframes split {
            from { width: 80%; opacity: 0; }
            to { width: 100%; opacity: 1; }
        }
        .anim-fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }
        .interactive-display {
            transition: all 0.3s ease-in-out;
        }
        canvas {
            display: block;
            width: 100%;
        }
        #range-canvas { height: 120px; }
        #quantization-canvas { height: 250px; }
    </style>
</head>
<body class="bg-black text-green-500 p-4 sm:p-6 md:p-8" style="font-family: 'Inter', sans-serif;">

    <main class="max-w-4xl mx-auto">
        <h1 class="text-4xl font-bold text-green-200 mb-6 text-center">Tutorial: Deconstructing Floating-Point Numbers</h1>
        <p class="text-lg text-center text-green-400 mb-10">Understanding the 1s and 0s that power modern AI.</p>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-green-300 mb-4 border-b border-green-800 pb-2">Introduction: Scientific Notation for Computers</h2>
            
            <!-- Animation Container -->
            <div id="animation-container" class="my-8 h-40 bg-gray-900/70 border border-green-700 rounded-lg p-4 flex flex-col items-center justify-center text-lg sm:text-xl font-mono relative overflow-hidden">
                <!-- Animation content will be generated by JavaScript -->
            </div>

            <p class="text-lg leading-relaxed">
                At its core, a floating-point number is how computers represent numbers with fractional parts (like 3.14159) or very large/small values. Think of it as a compact, binary version of scientific notation. Instead of writing 1.23 &times; 10<sup>5</sup>, a computer stores a number in three distinct parts: a sign, a mantissa (the significant digits), and an exponent.
            </p>
        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-green-300 mb-4 border-b border-green-800 pb-2">The Three Core Components</h2>
            <p class="text-lg leading-relaxed mb-6">
                Every floating-point number, regardless of its size (like 8-bit, 16-bit, or 32-bit), is composed of the same three fundamental pieces. Let's use the 8-bit (FP8) formats, popular in AI, as our examples.
            </p>
            <div class="grid md:grid-cols-3 gap-8">
                <!-- Sign Bit, Exponent, Mantissa cards... -->
                <div class="bg-gray-900/50 border border-green-900 p-6 rounded-lg">
                    <h3 class="text-xl font-bold text-green-200 mb-2">1. The Sign Bit (S)</h3>
                    <p class="leading-relaxed">A single bit that transmits the simplest piece of information: is the number positive or negative?</p>
                    <ul class="list-disc list-inside mt-4 space-y-2">
                        <li><code class="bg-green-900 text-white px-2 py-1 rounded">0</code> = Positive (+)</li>
                        <li><code class="bg-green-900 text-white px-2 py-1 rounded">1</code> = Negative (-)</li>
                    </ul>
                </div>
                <div class="bg-gray-900/50 border border-green-900 p-6 rounded-lg">
                    <h3 class="text-xl font-bold text-green-200 mb-2">2. The Exponent (E)</h3>
                    <p class="leading-relaxed">A sequence of bits that transmits the <strong class="text-green-300">magnitude</strong> or <strong class="text-green-300">range</strong> of the number. It scales the value up or down by a power of 2.</p>
                </div>
                <div class="bg-gray-900/50 border border-green-900 p-6 rounded-lg">
                    <h3 class="text-xl font-bold text-green-200 mb-2">3. The Mantissa (M)</h3>
                    <p class="leading-relaxed">Also called the significand, this sequence of bits transmits the <strong class="text-green-300">precision</strong> or <strong class="text-green-300">granularity</strong>. It represents the actual digits of the number.</p>
                </div>
            </div>
        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-green-300 mb-4 border-b border-green-800 pb-2">The AI Trade-Off: Interactive Demo</h2>
            <p class="text-lg leading-relaxed mb-6">
                An 8-bit float uses <strong class="text-cyan-400">1 bit for the sign</strong>, leaving <strong class="text-green-300">7 bits</strong> to be divided between the exponent and mantissa. This creates a trade-off between <strong class="text-yellow-400">range</strong> and <strong class="text-purple-400">precision</strong>. The visualizations below show the abstract limits and the practical effect on a function.
            </p>

            <!-- Interactive Tutorial -->
            <div class="bg-gray-900/50 border border-green-800 rounded-lg p-6">
                <div class="flex justify-center space-x-4 mb-6">
                    <button id="btn-e4m3" class="w-full sm:w-auto text-lg font-bold py-2 px-6 rounded-lg transition-all duration-300 border-2">E4M3 (More Precision)</button>
                    <button id="btn-e5m2" class="w-full sm:w-auto text-lg font-bold py-2 px-6 rounded-lg transition-all duration-300 border-2">E5M2 (More Range)</button>
                </div>
                
                <div id="bit-display" class="my-4 p-3 bg-gray-900 rounded-md text-center font-mono text-xl text-white interactive-display"></div>

                <!-- Visualization 1: Range -->
                <h3 class="text-xl font-semibold text-green-300 mt-8 mb-4">Visualization 1: Representable Range (Log Scale)</h3>
                <div class="my-6">
                    <canvas id="range-canvas"></canvas>
                </div>
                <div class="grid sm:grid-cols-2 gap-6 text-center">
                    <div class="interactive-display bg-gray-900 p-4 rounded-lg border border-gray-700">
                        <h4 class="text-lg font-semibold text-green-300 mb-2">Maximum Value</h4>
                        <p id="max-value" class="text-3xl font-bold text-white"></p>
                    </div>
                    <div class="interactive-display bg-gray-900 p-4 rounded-lg border border-gray-700">
                        <h4 class="text-lg font-semibold text-green-300 mb-2">Smallest Positive Value</h4>
                        <p id="min-value" class="text-3xl font-bold text-white"></p>
                    </div>
                </div>

                <!-- Visualization 2: Convergence -->
                <h3 class="text-xl font-semibold text-green-300 mt-8 mb-4">Visualization 2: Function Convergence</h3>
                <div class="my-6">
                    <canvas id="quantization-canvas"></canvas>
                </div>
                
                <!-- Algorithm Display -->
                <h3 class="text-xl font-semibold text-green-300 mt-8 mb-4">The Quantization Algorithm</h3>
                <pre id="algo-display" class="bg-gray-900 text-gray-200 p-4 rounded-lg overflow-x-auto font-mono text-sm interactive-display"></pre>
                
                <div id="explanation" class="interactive-display mt-8 p-4 bg-black/30 rounded-lg text-lg leading-relaxed"></div>
            </div>
        </section>

        <!-- Live Conversion Demo -->
        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-green-300 mb-4 border-b border-green-800 pb-2">Live Conversion Demo</h2>
            <p class="text-lg leading-relaxed mb-6">
                Enter a decimal number and select a format to see the full compression and decompression cycle, revealing any loss of precision.
            </p>

            <div class="bg-gray-900/50 border border-green-800 rounded-lg p-6">
                <!-- Input Form -->
                <div class="flex flex-col sm:flex-row items-center gap-4 mb-6">
                    <input type="number" id="decimal-input" placeholder="e.g., -26.75" value="-26.75" class="bg-gray-800 border border-gray-600 text-white text-lg rounded-lg p-2 w-full sm:w-1/3 focus:ring-green-500 focus:border-green-500">
                    <div class="flex items-center space-x-4">
                        <label class="flex items-center">
                            <input type="radio" name="conversion-format" value="e4m3" checked class="form-radio h-5 w-5 text-purple-500 bg-gray-700 border-gray-600 focus:ring-purple-500">
                            <span class="ml-2 text-purple-400">E4M3</span>
                        </label>
                        <label class="flex items-center">
                            <input type="radio" name="conversion-format" value="e5m2" class="form-radio h-5 w-5 text-yellow-500 bg-gray-700 border-gray-600 focus:ring-yellow-500">
                            <span class="ml-2 text-yellow-400">E5M2</span>
                        </label>
                    </div>
                    <button id="convert-btn" class="w-full sm:w-auto bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg transition-colors">Convert</button>
                </div>

                <!-- Results Display -->
                <div id="conversion-steps" class="space-y-4 font-mono text-gray-300">
                    <!-- Steps will be dynamically inserted here -->
                </div>
            </div>
        </section>

        <section>
            <h2 class="text-3xl font-semibold text-green-300 mb-4 border-b border-green-800 pb-2">Conclusion</h2>
            <p class="text-lg leading-relaxed">
                Understanding this trade-off between range and precision is key to understanding modern AI hardware. By choosing the right floating-point format for the job, engineers can design chips that are faster, more efficient, and more powerful. It's a fundamental concept that balances the need to represent a wide variety of numbers with the need for accuracy.
            </p>
            <p class="mt-6 text-center text-sm text-green-600">
                For more information, see the <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic" target="_blank" rel="noopener noreferrer" class="text-green-400 hover:text-green-300 underline">Wikipedia article on Floating-Point Arithmetic</a>.
            </p>
        </section>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Animation Logic ---
            const animContainer = document.getElementById('animation-container');
            if (animContainer) {
                const animStates = [
                    () => { animContainer.innerHTML = `<div class="anim-fade-in text-green-300">A number like -26.75</div>`; },
                    () => { animContainer.innerHTML = `<div class="w-full max-w-sm h-12 bg-gray-800 border-2 border-green-600 rounded-md anim-fade-in"></div>`; },
                    () => { animContainer.innerHTML = `<div class="w-full max-w-sm flex justify-between space-x-2" style="animation: split 0.5s ease-out forwards;"><div class="w-1/6 h-12 bg-gray-800 border-2 border-cyan-500 rounded-md flex items-center justify-center text-cyan-400">S</div><div class="w-3/6 h-12 bg-gray-800 border-2 border-yellow-500 rounded-md flex items-center justify-center text-yellow-400">Exponent</div><div class="w-2/6 h-12 bg-gray-800 border-2 border-purple-500 rounded-md flex items-center justify-center text-purple-400">Mantissa</div></div>`; },
                    () => { animContainer.innerHTML = `<div class="w-full max-w-sm flex justify-between space-x-2"><div class="flex flex-col items-center"><div class="w-12 h-12 bg-gray-800 border-2 border-cyan-500 rounded-md flex items-center justify-center text-cyan-400 anim-fade-in">1</div><div class="mt-2 text-sm text-cyan-400 anim-fade-in" style="animation-delay: 0.2s;">Sign</div></div><div class="flex flex-col items-center"><div class="h-12 px-2 bg-gray-800 border-2 border-yellow-500 rounded-md flex items-center justify-center text-yellow-400 anim-fade-in">10000011</div><div class="mt-2 text-sm text-yellow-400 anim-fade-in" style="animation-delay: 0.2s;">Exponent</div></div><div class="flex flex-col items-center"><div class="h-12 px-2 bg-gray-800 border-2 border-purple-500 rounded-md flex items-center justify-center text-purple-400 anim-fade-in">101011...</div><div class="mt-2 text-sm text-purple-400 anim-fade-in" style="animation-delay: 0.2s;">Mantissa</div></div></div>`; },
                    () => { animContainer.innerHTML = `<div class="w-full text-center anim-fade-in"><div class="text-base text-green-400">Reconstructing the number:</div><div class="text-xl sm:text-2xl mt-2 text-green-200 font-bold">(-1) &times; (1.101011)<sub>2</sub> &times; 2<sup>4</sup> = -26.75</div></div>`; }
                ];
                let currentAnimState = 0;
                const runAnimation = () => {
                    animStates[currentAnimState]();
                    currentAnimState = (currentAnimState + 1) % animStates.length;
                };
                runAnimation();
                setInterval(runAnimation, 4500);
            }

            // --- Interactive Tutorial Logic ---
            const btnE4M3 = document.getElementById('btn-e4m3');
            const btnE5M2 = document.getElementById('btn-e5m2');
            const explanationEl = document.getElementById('explanation');
            const bitDisplayEl = document.getElementById('bit-display');
            const algoDisplayEl = document.getElementById('algo-display');
            const maxValueEl = document.getElementById('max-value');
            const minValueEl = document.getElementById('min-value');
            const rangeCanvas = document.getElementById('range-canvas');
            const quantizationCanvas = document.getElementById('quantization-canvas');
            const rangeCtx = rangeCanvas.getContext('2d');
            const qCtx = quantizationCanvas.getContext('2d');
            const convertBtn = document.getElementById('convert-btn');

            const data = {
                e4m3: {
                    max_val: 240, min_val: 0.015625,
                    max_exp: 7, mantissa_bits: 3, bias: 7,
                    bits: `<span class="text-cyan-400">S</span> | <span class="text-yellow-400">EEEE</span> | <span class="text-purple-400">MMM</span>`,
                    explanation: `The <strong class="text-purple-400">E4M3</strong> line on the convergence graph has finer, closer steps. This means it represents the "true" value with higher fidelity, but it quickly hits its maximum and "clamps," unable to represent larger values. It prioritizes <strong class="text-purple-400">precision</strong> over range.`
                },
                e5m2: {
                    max_val: 57344, min_val: 0.000061,
                    max_exp: 15, mantissa_bits: 2, bias: 15,
                    bits: `<span class="text-cyan-400">S</span> | <span class="text-yellow-400">EEEEE</span> | <span class="text-purple-400">MM</span>`,
                    explanation: `The <strong class="text-yellow-400">E5M2</strong> line has coarser, larger steps, making it a less accurate approximation. However, its superior range (visible on the top graph) allows it to follow the true value much further. It prioritizes <strong class="text-yellow-400">range</strong> over precision.`
                }
            };
            
            const algoTemplate = (params) => `
<span class="text-green-400">// Simplified quantization for a given value</span>
<span class="text-cyan-400">function</span> quantize(value) {
  <span class="text-cyan-400">const</span> MANTISSA_BITS = <span class="text-yellow-300">${params.mantissa_bits}</span>;
  <span class="text-cyan-400">const</span> MAX_EXPONENT  = <span class="text-yellow-300">${params.max_exp}</span>;
  <span class="text-cyan-400">const</span> BIAS          = <span class="text-yellow-300">${params.bias}</span>;

  <span class="text-green-400">// 1. Find the scale (power of 2)</span>
  <span class="text-cyan-400">let</span> exponent = floor(log2(abs(value)));
  <span class="text-cyan-400">if</span> (exponent > MAX_EXPONENT) {
    exponent = MAX_EXPONENT;
  }
  <span class="text-cyan-400">const</span> scale = 2 ** exponent;

  <span class="text-green-400">// 2. Normalize value and find closest mantissa step</span>
  <span class="text-cyan-400">const</span> mantissa_steps = 2 ** MANTISSA_BITS;
  <span class="text-cyan-400">const</span> normalized = abs(value) / scale;
  <span class="text-cyan-400">const</span> mantissa = 1 + round((normalized - 1) * mantissa_steps) / mantissa_steps;

  <span class="text-green-400">// 3. Reconstruct the quantized value</span>
  <span class="text-cyan-400">return</span> mantissa * scale;
}`;

            let currentFormat = 'e4m3';

            function quantize(value, format) {
                if (value === 0) return 0;
                const { max_exp, mantissa_bits } = data[format];
                const mantissa_steps = Math.pow(2, mantissa_bits);

                let exponent = Math.floor(Math.log2(Math.abs(value)));
                if (exponent > max_exp) exponent = max_exp;
                
                const scale = Math.pow(2, exponent);
                const normalized_val = Math.abs(value) / scale;
                
                const mantissa = 1 + Math.round((normalized_val - 1) * mantissa_steps) / mantissa_steps;
                let quantized_val = mantissa * scale;
                
                const max_val = (2 - 1/mantissa_steps) * Math.pow(2, max_exp);
                if (quantized_val > max_val) quantized_val = max_val;

                return quantized_val * Math.sign(value);
            }

            function drawRangeGraph() {
                const dpr = window.devicePixelRatio || 1;
                const rect = rangeCanvas.getBoundingClientRect();
                rangeCanvas.width = rect.width * dpr;
                rangeCanvas.height = rect.height * dpr;
                rangeCtx.scale(dpr, dpr);
                
                const width = rangeCanvas.clientWidth;
                const height = rangeCanvas.clientHeight;
                const padding = 20;

                rangeCtx.clearRect(0, 0, width, height);
                rangeCtx.font = '12px "Inter", sans-serif';

                const overallMin = Math.log10(data.e5m2.min_val);
                const overallMax = Math.log10(data.e5m2.max_val);
                const range = overallMax - overallMin;

                const valueToX = (val) => padding + ((Math.log10(val) - overallMin) / range) * (width - 2 * padding);

                rangeCtx.strokeStyle = '#3f6212';
                rangeCtx.lineWidth = 1;
                rangeCtx.beginPath();
                rangeCtx.moveTo(padding, height / 2);
                rangeCtx.lineTo(width - padding, height / 2);
                rangeCtx.stroke();

                for (let i = Math.floor(overallMin); i <= Math.ceil(overallMax); i++) {
                    const x = valueToX(Math.pow(10, i));
                    rangeCtx.beginPath();
                    rangeCtx.moveTo(x, height / 2 - 5);
                    rangeCtx.lineTo(x, height / 2 + 5);
                    rangeCtx.stroke();
                    rangeCtx.fillStyle = '#86efac';
                    rangeCtx.textAlign = 'center';
                    rangeCtx.fillText(`10^${i}`, x, height / 2 + 20);
                }

                const e5_y = height / 2 - 15;
                const e5_x_min = valueToX(data.e5m2.min_val);
                const e5_x_max = valueToX(data.e5m2.max_val);
                rangeCtx.fillStyle = currentFormat === 'e5m2' ? '#facc15' : '#422006';
                rangeCtx.fillRect(e5_x_min, e5_y - 2, e5_x_max - e5_x_min, 4);
                rangeCtx.fillStyle = '#facc15';
                rangeCtx.fillText('E5M2', padding, e5_y + 4);

                const e4_y = height / 2 + 15;
                const e4_x_min = valueToX(data.e4m3.min_val);
                const e4_x_max = valueToX(data.e4m3.max_val);
                rangeCtx.fillStyle = currentFormat === 'e4m3' ? '#c084fc' : '#2e1065';
                rangeCtx.fillRect(e4_x_min, e4_y - 6, e4_x_max - e4_x_min, 12);
                rangeCtx.fillStyle = '#c084fc';
                rangeCtx.fillText('E4M3', padding, e4_y + 4);
            }

            function drawConvergenceGraph() {
                const dpr = window.devicePixelRatio || 1;
                const rect = quantizationCanvas.getBoundingClientRect();
                quantizationCanvas.width = rect.width * dpr;
                quantizationCanvas.height = rect.height * dpr;
                qCtx.scale(dpr, dpr);
                
                const width = quantizationCanvas.clientWidth;
                const height = quantizationCanvas.clientHeight;
                const padding = 30;

                qCtx.clearRect(0, 0, width, height);
                qCtx.font = '12px "Inter", sans-serif';
                
                const xMax = 300;
                const yMax = 300;

                const toScreenX = (x) => padding + (x / xMax) * (width - 2 * padding);
                const toScreenY = (y) => (height - padding) - (y / yMax) * (height - 2 * padding);

                qCtx.strokeStyle = '#3f6212';
                qCtx.lineWidth = 1;
                qCtx.beginPath();
                qCtx.moveTo(padding, padding);
                qCtx.lineTo(padding, height - padding);
                qCtx.lineTo(width - padding, height - padding);
                qCtx.stroke();
                qCtx.fillStyle = '#86efac';
                qCtx.fillText('0', padding - 10, height - padding + 10);
                
                qCtx.beginPath();
                qCtx.strokeStyle = '#166534';
                qCtx.lineWidth = 1;
                qCtx.moveTo(toScreenX(0), toScreenY(0));
                qCtx.lineTo(toScreenX(xMax), toScreenY(yMax));
                qCtx.stroke();
                qCtx.fillText("True Value", toScreenX(150), toScreenY(135));

                function drawQuantizedLine(format, color, lineWidth) {
                    qCtx.beginPath();
                    qCtx.strokeStyle = color;
                    qCtx.lineWidth = lineWidth;
                    let lastY = toScreenY(0);
                    qCtx.moveTo(toScreenX(0), lastY);

                    for (let x = 1; x < xMax; x++) {
                        const quantizedY = quantize(x, format);
                        const screenY = toScreenY(quantizedY);
                        qCtx.lineTo(toScreenX(x - 1), lastY);
                        qCtx.lineTo(toScreenX(x), lastY);
                        lastY = screenY;
                    }
                    qCtx.stroke();
                }

                drawQuantizedLine('e5m2', currentFormat === 'e5m2' ? '#facc15' : '#422006', currentFormat === 'e5m2' ? 3 : 1);
                drawQuantizedLine('e4m3', currentFormat === 'e4m3' ? '#c084fc' : '#2e1065', currentFormat === 'e4m3' ? 3 : 1);
            }

            function updateDisplay(format) {
                currentFormat = format;
                const formatData = data[format];

                [explanationEl, bitDisplayEl, algoDisplayEl, maxValueEl, minValueEl].forEach(el => {
                    el.classList.remove('anim-fade-in');
                    void el.offsetWidth;
                });

                if (format === 'e4m3') {
                    btnE4M3.classList.add('bg-purple-500', 'text-black', 'border-purple-500');
                    btnE4M3.classList.remove('border-gray-600', 'text-green-500');
                    btnE5M2.classList.add('border-gray-600', 'text-green-500');
                    btnE5M2.classList.remove('bg-yellow-500', 'text-black', 'border-yellow-500');
                } else {
                    btnE5M2.classList.add('bg-yellow-500', 'text-black', 'border-yellow-500');
                    btnE5M2.classList.remove('border-gray-600', 'text-green-500');
                    btnE4M3.classList.add('border-gray-600', 'text-green-500');
                    btnE4M3.classList.remove('bg-purple-500', 'text-black', 'border-purple-500');
                }
                
                bitDisplayEl.innerHTML = formatData.bits;
                maxValueEl.textContent = formatData.max_val;
                minValueEl.textContent = formatData.min_val;
                algoDisplayEl.innerHTML = algoTemplate(formatData);
                explanationEl.innerHTML = formatData.explanation;

                [explanationEl, bitDisplayEl, algoDisplayEl, maxValueEl, minValueEl].forEach(el => {
                    el.classList.add('anim-fade-in');
                });

                drawRangeGraph();
                drawConvergenceGraph();
            }

            function handleConversion() {
                const inputEl = document.getElementById('decimal-input');
                const stepsEl = document.getElementById('conversion-steps');
                const format = document.querySelector('input[name="conversion-format"]:checked').value;
                
                stepsEl.innerHTML = ''; // Clear previous results
                const value = parseFloat(inputEl.value);

                if (isNaN(value)) {
                    stepsEl.innerHTML = '<div class="p-3 bg-red-900/50 rounded-lg text-red-300">Please enter a valid number.</div>';
                    return;
                }

                const formatData = data[format];
                let delay = 0;

                function displayStep(title, content, highlightClass = 'text-green-300') {
                    setTimeout(() => {
                        const stepDiv = document.createElement('div');
                        stepDiv.className = 'p-3 bg-gray-800/50 rounded-lg anim-fade-in';
                        stepDiv.innerHTML = `
                            <div class="text-gray-400 text-sm">${title}</div>
                            <div class="text-lg break-words ${highlightClass}">${content}</div>
                        `;
                        stepsEl.appendChild(stepDiv);
                    }, delay);
                    delay += 350; // Stagger the appearance of each step
                }

                // Step 1: Sign
                const signBit = value < 0 ? 1 : 0;
                displayStep('Step 1: Determine Sign Bit', `Input: ${value} -> <strong class="text-cyan-400">Sign Bit = ${signBit}</strong>`);

                // Step 2: To Binary
                const absValue = Math.abs(value);
                const intPart = Math.floor(absValue);
                let fracPart = absValue - intPart;
                const intBinary = intPart.toString(2);
                let fracBinary = '';
                let guard = 0;
                while(fracPart > 0 && guard < 24) {
                    fracPart *= 2;
                    if (fracPart >= 1) {
                        fracBinary += '1';
                        fracPart -= 1;
                    } else {
                        fracBinary += '0';
                    }
                    guard++;
                }
                const fullBinary = fracBinary.length > 0 ? `${intBinary}.${fracBinary}` : intBinary;
                displayStep('Step 2: Convert to Binary', `${absValue} -> <strong class="text-green-300">${fullBinary}</strong>`);
                
                // Step 3: Normalize
                let exponent = 0;
                let normalizedFrac = '';
                if (intPart > 0) {
                    exponent = intBinary.length - 1;
                    normalizedFrac = (intBinary.substring(1) + fracBinary);
                } else {
                    const firstFracOne = fracBinary.indexOf('1');
                    if (firstFracOne === -1) {
                        exponent = -formatData.bias;
                        normalizedFrac = '';
                    } else {
                        exponent = -(firstFracOne + 1);
                        normalizedFrac = fracBinary.substring(firstFracOne + 1);
                    }
                }
                const normalizedBinaryDisplay = `1.${normalizedFrac}`;
                displayStep('Step 3: Normalize Binary', `${fullBinary} -> <strong class="text-green-300">${normalizedBinaryDisplay}</strong> &times; 2<sup>${exponent}</sup>`);

                // Step 4: Exponent
                const biasedExponent = exponent + formatData.bias;
                const exponentBits = biasedExponent.toString(2).padStart(format === 'e4m3' ? 4 : 5, '0');
                displayStep('Step 4: Calculate Exponent Bits', `(Exponent + Bias) = (${exponent} + ${formatData.bias}) = ${biasedExponent} -> <strong class="text-yellow-400">Exponent Bits = ${exponentBits}</strong>`);

                // Step 5: Mantissa
                const mantissaBits = normalizedFrac.substring(0, formatData.mantissa_bits).padEnd(formatData.mantissa_bits, '0');
                displayStep('Step 5: Extract Mantissa Bits', `From ${normalizedBinaryDisplay}, take ${formatData.mantissa_bits} bits -> <strong class="text-purple-400">Mantissa Bits = ${mantissaBits}</strong>`);

                // Step 6: Assemble
                const finalBinary = `<span class="text-cyan-400">${signBit}</span> | <span class="text-yellow-400">${exponentBits}</span> | <span class="text-purple-400">${mantissaBits}</span>`;
                displayStep('Step 6: Final Assembly (S | E | M)', `Result: <strong class="text-2xl text-white">${finalBinary}</strong>`, 'text-white');

                // Step 7: Decompress
                const decompressedExponentVal = parseInt(exponentBits, 2);
                const decompressedTrueExponent = decompressedExponentVal - formatData.bias;
                const mantissaDecimal = parseInt(mantissaBits, 2);
                const mantissaFraction = mantissaDecimal / Math.pow(2, formatData.mantissa_bits);
                const fullMantissa = 1 + mantissaFraction;
                const decompressedValue = (signBit === 1 ? -1 : 1) * fullMantissa * Math.pow(2, decompressedTrueExponent);
                displayStep('Step 7: Decompress back to Decimal', 
                    `S=${signBit}, E=${decompressedExponentVal}, M=${mantissaDecimal}<br>`+
                    `Calc: ${signBit === 1 ? -1 : 1} &times; (1 + ${mantissaDecimal}/2<sup>${formatData.mantissa_bits}</sup>) &times; 2<sup>(${decompressedExponentVal}-${formatData.bias})</sup> = <strong class="text-green-300">${decompressedValue.toPrecision(8)}</strong>`
                );

                // Step 8: Compare
                const error = Math.abs(value - decompressedValue);
                const errorPercentage = value !== 0 ? (error / Math.abs(value)) * 100 : 0;
                displayStep('Step 8: Compare & Show Error', 
                    `Original Input: ${value}<br>` +
                    `Stored Value:   ${decompressedValue.toPrecision(8)}<br>` +
                    `Precision Loss (Error): <strong class="text-red-400">${error.toPrecision(4)} (${errorPercentage.toFixed(2)}%)</strong>`,
                    'text-white'
                );
            }

            btnE4M3.addEventListener('click', () => updateDisplay('e4m3'));
            btnE5M2.addEventListener('click', () => updateDisplay('e5m2'));
            convertBtn.addEventListener('click', handleConversion);
            
            const resizeObserver = new ResizeObserver(() => {
                drawRangeGraph();
                drawConvergenceGraph();
            });
            resizeObserver.observe(document.body);

            // Initial state and first conversion
            updateDisplay('e4m3');
            handleConversion();
        });
    </script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nested Toroid Generator</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js for 3D visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .three-container {
            height: 500px;
            background-color: #020f02; /* Very dark green */
            border-radius: 0.75rem;
            border: 1px solid #052e16;
            position: relative;
            overflow: hidden;
            cursor: move;
        }
        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 8px;
            background: #064e3b; /* Dark green */
            border-radius: 5px; 
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 20px; height: 20px;
            background: #10b981; /* Bright green */
            cursor: pointer; 
            border-radius: 50%;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px; height: 20px;
            background: #10b981; /* Bright green */
            cursor: pointer; 
            border-radius: 50%;
        }
    </style>
</head>
<body class="bg-black text-green-500 p-4 sm:p-6 md:p-8" style="font-family: 'Inter', sans-serif;">

    <div class="container mx-auto max-w-4xl">

        <header class="text-center mb-10">
            <h1 class="text-4xl font-bold text-green-200 mb-6">Nested Toroid Generator</h1>
            <p class="text-xl text-green-300 font-semibold mt-2">Dual Field Simulation</p>
        </header>

        <main class="bg-gray-900/50 border border-green-800 p-6 md:p-8 rounded-2xl shadow-lg">
            <section id="simulation">
                <h2 class="text-2xl font-semibold text-green-300 mb-4 border-b border-green-800 pb-2">Interactive Simulation</h2>
                <p class="mb-4 text-lg leading-relaxed">This simulation visualizes two independent toroidal field pairs generated by a single bifilar coil. Use the controls to adjust each field's properties. <br><b>Camera Controls:</b> Left-drag to rotate, Right-drag to pan, Scroll to zoom.</p>
                <div id="simulation-container" class="three-container"></div>
                <div id="controls-panel" class="mt-4 p-4 bg-gray-900 rounded-lg space-y-4">
                    <!-- Control sections will be injected here by script -->
                </div>
            </section>
            
            <section id="theory" class="mt-8">
                <h2 class="text-2xl font-semibold text-green-300 mb-4 border-b border-green-800 pb-2">Predictive Algorithms and Data Diffusion</h2>
                <p class="text-lg leading-relaxed">
                    The visualization demonstrates a theoretical model for data interaction. By conceptualizing data streams as nested toroidal fields, we can explore concepts like data diffusion and drift. The primary toroid (Red/Blue) can represent a core dataset or a primary influencing factor, while the secondary toroid (Green/Yellow) can represent an intersecting data stream or external variable.
                </p>
                <p class="text-lg leading-relaxed mt-4">
                    By precisely controlling the amplitude, pulse, and orientation of each toroidal flow, it becomes possible to model and create predictive paths. For instance, adjusting the "Pulse Frequency" can simulate the rate of data flow, while "Amplitude" and "Size" can represent the data's influence or volume. The interaction points and resulting particle trajectories could then be used to develop predictive algorithms that forecast how these data streams might merge, diverge, or influence one another over time.
                </p>
            </section>

        </main>
        
        <footer class="text-center mt-10 text-sm text-green-600">
            <p>Project documentation. Last updated: <span id="date"></span>.</p>
        </footer>
    </div>

    <script>
        window.addEventListener('DOMContentLoaded', () => {
            // --- Utility Functions ---
            const toRadians = (degrees) => degrees * (Math.PI / 180);

            function addCameraControls(camera, domElement) {
                const target = new THREE.Vector3(0, 0, 0);
                let isRotating = false, isPanning = false;
                let previousMousePosition = { x: 0, y: 0 };
                const panSpeed = 0.02, zoomSpeed = 0.2;
                function onPointerDown(e) {
                    if (e.button === 0) isRotating = true;
                    if (e.button === 2) isPanning = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
                function onPointerUp() { isRotating = false; isPanning = false; }
                function onPointerMove(e) {
                    const deltaMove = { x: e.clientX - previousMousePosition.x, y: e.clientY - previousMousePosition.y };
                    if (isRotating) {
                        const deltaRotationQuaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(toRadians(deltaMove.y * 0.5), toRadians(deltaMove.x * 0.5), 0, 'YXZ'));
                        const offset = new THREE.Vector3().subVectors(camera.position, target);
                        offset.applyQuaternion(deltaRotationQuaternion);
                        camera.position.copy(target).add(offset);
                        camera.lookAt(target);
                    } else if (isPanning) {
                        const panOffset = new THREE.Vector3();
                        const v = new THREE.Vector3().subVectors(camera.position, target).normalize();
                        const u = new THREE.Vector3().crossVectors(camera.up, v).normalize();
                        panOffset.add(u.multiplyScalar(-deltaMove.x * panSpeed));
                        panOffset.add(camera.up.clone().multiplyScalar(deltaMove.y * panSpeed));
                        camera.position.add(panOffset);
                        target.add(panOffset);
                    }
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
                function onWheel(e) {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 1 : -1;
                    const direction = new THREE.Vector3().subVectors(target, camera.position).normalize();
                    camera.position.add(direction.multiplyScalar(delta * zoomSpeed));
                }
                domElement.addEventListener('contextmenu', e => e.preventDefault());
                domElement.addEventListener('pointerdown', onPointerDown);
                domElement.addEventListener('pointerup', onPointerUp);
                domElement.addEventListener('pointermove', onPointerMove);
                domElement.addEventListener('wheel', onWheel, { passive: false });
            }

            // --- Main Simulation Setup ---
            function initVisualization() {
                const container = document.getElementById('simulation-container');
                if (!container) return;

                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.set(0, 8, 20);
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                container.appendChild(renderer.domElement);
                
                scene.add(new THREE.AmbientLight(0xccffcc, 0.6));
                const dirLight = new THREE.DirectionalLight(0xccffcc, 0.8);
                dirLight.position.set(5, 10, 7.5);
                scene.add(dirLight);

                const masterCoilSystem = new THREE.Group();
                scene.add(masterCoilSystem);
                addCameraControls(camera, container);

                // --- State Management and UI Generation ---
                const fieldSystems = [];

                function createFieldSystem(id, name, colors, initialState, masterGroup) {
                    const systemState = { ...initialState };

                    const createParticleField = (color, isStrong) => {
                        const maxParticleCount = isStrong ? 3000 : 1500;
                        const geo = new THREE.BufferGeometry();
                        geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(maxParticleCount * 3), 3));
                        geo.setAttribute('meta', new THREE.BufferAttribute(new Float32Array(maxParticleCount * 2), 2));
                        for (let i = 0; i < maxParticleCount; i++) {
                            geo.attributes.meta.array[i * 2] = Math.random() * Math.PI * 2;
                            geo.attributes.meta.array[i * 2 + 1] = (0.5 + Math.random() * 0.5) * (Math.random() > 0.5 ? 1 : -1);
                        }
                        const mat = new THREE.PointsMaterial({ size: 0.08, color: color, transparent: true, opacity: 0.9 });
                        const field = new THREE.Points(geo, mat);
                        field.userData.isStrong = isStrong;
                        field.geometry.setDrawRange(0, Math.floor(maxParticleCount * systemState.density));
                        masterGroup.add(field);
                        return field;
                    };
                    
                    const strongField = createParticleField(colors.strong, true);
                    const weakField = createParticleField(colors.weak, false);
                    
                    const filterPlane = new THREE.Plane(new THREE.Vector3(1, 0, 0), 0);

                    const controlsHtml = `
                        <details class="border-b border-green-800 pb-4" open>
                            <summary class="font-semibold text-lg cursor-pointer" style="color:${colors.strong};">${name}</summary>
                            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 pt-4 text-green-400">
                                <div><label for="${id}-pulse">Pulse Freq: <span id="${id}-pulse-readout" class="font-mono text-green-300"></span></label><input type="range" id="${id}-pulse" min="0.1" max="5" step="0.1" value="${systemState.pulse}"></div>
                                <div><label for="${id}-amplitude">Amplitude: <span id="${id}-amplitude-readout" class="font-mono text-green-300"></span></label><input type="range" id="${id}-amplitude" min="2" max="8" step="0.1" value="${systemState.amplitude}"></div>
                                <div><label for="${id}-size">Size: <span id="${id}-size-readout" class="font-mono text-green-300"></span></label><input type="range" id="${id}-size" min="0.1" max="3" step="0.1" value="${systemState.size}"></div>
                                <div><label for="${id}-offset">Offset: <span id="${id}-offset-readout" class="font-mono text-green-300"></span></label><input type="range" id="${id}-offset" min="-5" max="5" step="0.1" value="${systemState.offset}"></div>
                                <div><label for="${id}-ellipse">Elliptical Ratio: <span id="${id}-ellipse-readout" class="font-mono text-green-300"></span></label><input type="range" id="${id}-ellipse" min="0.2" max="2.0" step="0.05" value="${systemState.ellipse}"></div>
                                <div><label for="${id}-density">Particle Density: <span id="${id}-density-readout" class="font-mono text-green-300"></span></label><input type="range" id="${id}-density" min="0.1" max="1.0" step="0.05" value="${systemState.density}"></div>
                            </div>
                            <h4 class="font-semibold text-green-300 mt-4 mb-2">Filter Plane Orientation</h4>
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-x-6 gap-y-2">
                                <div><label for="${id}-plane-rot-x">X-Axis</label><input type="range" id="${id}-plane-rot-x" min="-180" max="180" value="0"></div>
                                <div><label for="${id}-plane-rot-y">Y-Axis</label><input type="range" id="${id}-plane-rot-y" min="-180" max="180" value="0"></div>
                                <div><label for="${id}-plane-rot-z">Z-Axis</label><input type="range" id="${id}-plane-rot-z" min="-180" max="180" value="0"></div>
                            </div>
                        </details>
                    `;
                    document.getElementById('controls-panel').insertAdjacentHTML('beforeend', controlsHtml);
                    
                    const uiElements = {};
                    ['pulse', 'amplitude', 'size', 'offset', 'ellipse', 'density', 'plane-rot-x', 'plane-rot-y', 'plane-rot-z'].forEach(key => {
                        uiElements[key] = { slider: document.getElementById(`${id}-${key}`), readout: document.getElementById(`${id}-${key.split('-')[0]}-readout`) };
                    });

                    function updateUI() {
                         Object.keys(systemState).forEach(key => {
                            if(uiElements[key] && uiElements[key].readout) {
                                let value = systemState[key];
                                uiElements[key].readout.textContent = (key === 'ellipse' || key === 'density' ? value.toFixed(2) : value.toFixed(1));
                            }
                         });
                    }

                    Object.keys(uiElements).forEach(key => {
                        if (uiElements[key].slider) {
                            uiElements[key].slider.addEventListener('input', e => {
                                const value = parseFloat(e.target.value);
                                const prop = key.split('-')[0];
                                if (key.startsWith('plane')) {
                                   const axis = key.slice(-1);
                                   systemState.planeRotation[axis] = value;
                                } else {
                                   systemState[prop] = value;
                                }
                                if (prop === 'density') {
                                    strongField.geometry.setDrawRange(0, Math.floor(3000 * value));
                                    weakField.geometry.setDrawRange(0, Math.floor(1500 * value));
                                }
                                updateUI();
                            });
                        }
                    });

                    updateUI();
                    
                    return { systemState, strongField, weakField, filterPlane };
                }
                
                const coilModel = (() => {
                    const group = new THREE.Group();
                    const turns = 12, maxRadius = 2.0, wireSeparation = 0.08;
                    const mat1 = new THREE.LineBasicMaterial({ color: '#6EE7B7' });
                    const mat2 = new THREE.LineBasicMaterial({ color: '#34D399' });
                    const p1 = [], p2 = [];
                    for (let i = 0; i <= turns * 360; i++) {
                        const angle = toRadians(i), radius = (i / (turns * 360)) * maxRadius;
                        p1.push(new THREE.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius));
                        const angle2 = angle + toRadians(wireSeparation / radius * 360 || 0);
                        p2.push(new THREE.Vector3(Math.cos(angle2) * radius, 0, Math.sin(angle2) * radius));
                    }
                    group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(p1), mat1));
                    group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(p2), mat2));
                    return group;
                })();
                masterCoilSystem.add(coilModel); // FIX: This now correctly adds to masterCoilSystem.

                fieldSystems.push(createFieldSystem('primary', 'Primary Field', {strong: '#6EE7B7', weak: '#34D399'}, {
                    pulse: 1.0, amplitude: 4.0, size: 0.8, offset: 0.0, ellipse: 1.0, density: 1.0,
                    planeRotation: {x: 0, y: 0, z: 0}
                }, masterCoilSystem));
                
                fieldSystems.push(createFieldSystem('secondary', 'Secondary Field', {strong: '#A7F3D0', weak: '#FBBF24'}, {
                    pulse: 1.2, amplitude: 2.5, size: 0.5, offset: 0.0, ellipse: 1.0, density: 1.0,
                    planeRotation: {x: 0, y: 0, z: 0}
                }, masterCoilSystem));

                const clock = new THREE.Clock();
                const point = new THREE.Vector3();
                const planeQuaternion = new THREE.Quaternion();
                const euler = new THREE.Euler();

                function updateField(particles, state, isStrong, filterPlane) {
                    const positions = particles.geometry.attributes.position.array;
                    const meta = particles.geometry.attributes.meta.array;
                    const time = clock.getElapsedTime();
                    
                    const amplitude = state.amplitude * (isStrong ? 1 : 1/3);
                    const size = state.size * (isStrong ? 1 : 1/3);
                    const { offset, pulse, ellipse } = state;
                    
                    for (let i = 0; i < meta.length / 2; i++) {
                        const i2 = i * 2, i3 = i * 3;
                        const v = meta[i2], u_speed = meta[i2 + 1];
                        const u = time * pulse * 0.3 * u_speed;
                        
                        const R = amplitude + size * Math.cos(v);
                        const px = R * Math.cos(u) * ellipse;
                        const py = size * Math.sin(v) + offset;
                        const pz = R * Math.sin(u);

                        point.set(px, py, pz);
                        
                        const distanceToPlane = filterPlane.distanceToPoint(point);
                        const isVisible = !( (isStrong && distanceToPlane > 0) || (!isStrong && distanceToPlane < 0) );

                        if (isVisible) {
                           positions[i3] = px; positions[i3 + 1] = py; positions[i3 + 2] = pz;
                        } else {
                           positions[i3] = 99999;
                           positions[i3 + 1] = 99999;
                           positions[i3 + 2] = 99999;
                        }
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                }

                function animate() {
                    requestAnimationFrame(animate);

                    fieldSystems.forEach(system => {
                        const { systemState, strongField, weakField, filterPlane } = system;
                        
                        euler.set(toRadians(systemState.planeRotation.x), toRadians(systemState.planeRotation.y), toRadians(systemState.planeRotation.z), 'XYZ');
                        planeQuaternion.setFromEuler(euler);
                        filterPlane.normal.set(1, 0, 0).applyQuaternion(planeQuaternion);
                        
                        updateField(strongField, systemState, true, filterPlane);
                        updateField(weakField, systemState, false, filterPlane);
                    });

                    renderer.render(scene, camera);
                }
                
                animate();
            }

            initVisualization();
            document.getElementById('date').textContent = new Date().toLocaleDateString('en-US', {
                year: 'numeric', month: 'long', day: 'numeric' 
            });
        });
    </script>
</body>
</html>

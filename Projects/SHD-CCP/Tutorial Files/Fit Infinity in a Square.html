<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quaternion Visualization Pipeline</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* gray-900 */
            color: #d1d5db; /* gray-300 */
        }
        .viz-container {
            background-color: #1f2937; /* gray-800 */
            border: 1px solid #374151; /* gray-700 */
            border-radius: 0.75rem; /* rounded-lg */
            padding: 1.5rem; /* p-6 */
            min-height: 400px;
        }
        svg {
            display: block;
            margin: auto;
            background-color: #374151; /* gray-700 */
            border-radius: 0.5rem; /* rounded-md */
        }
        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: #374151; /* gray-700 */
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        .slider:hover {
            opacity: 1;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #60a5fa; /* blue-400 */
            cursor: pointer;
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #60a5fa; /* blue-400 */
            cursor: pointer;
        }
        .slider:disabled::-webkit-slider-thumb {
            background: #4b5563; /* gray-600 */
        }
        .slider:disabled::-moz-range-thumb {
            background: #4b5563; /* gray-600 */
        }
        select {
            background-color: #374151; /* gray-700 */
            border-color: #4b5563; /* gray-600 */
        }
    </style>
    
    <!-- Import Map for Three.js ES Modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.137.0",
            "three/addons/": "https://esm.sh/three@0.137.0/examples/jsm/"
        }
    }
    </script>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-7xl mx-auto">
        <h1 class="text-3xl font-bold text-white text-center mb-4">"Fit Infinity in a Square" Pipeline</h1>
        <p class="text-center text-gray-400 mb-8">An interactive visualization of the S³ &rarr; S² &rarr; D² &rarr; [0,1]² mapping pipeline.</p>

        <!-- Controls -->
        <div class="bg-gray-800 rounded-lg p-6 mb-8">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Slider -->
                <div>
                    <label for="param-slider" class="block text-sm font-medium text-white mb-2">Adjust State (Parameter $t$)</label>
                    <input id="param-slider" type="range" min="0" max="1" step="0.001" value="0" class="slider">
                </div>
                <!-- Path Selector -->
                <div>
                    <label for="path-selector" class="block text-sm font-medium text-white mb-2">Select Path Algorithm</label>
                    <select id="path-selector" class="w-full bg-gray-700 border-gray-600 text-white rounded p-2 h-10">
                        <option value="trefoil-knot" selected>Trefoil Knot Path (Default)</option>
                        <option value="knot">Knot Path</option>
                        <option value="simple-twist">Simple Z-Twist Path</option>
                        <option value="lissajous">Lissajous Path</option>
                    </select>
                </div>
            </div>
            <!-- Animation Controls -->
            <div class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <label for="animation-mode" class="block text-sm font-medium text-white mb-2">Animation Mode</label>
                    <select id="animation-mode" class="w-full bg-gray-700 border-gray-600 text-white rounded p-2 h-10">
                        <option value="off" selected>Off</option>
                        <option value="oscillate">Oscillate (Ping-Pong)</option>
                        <option value="loop">Loop (Continuous)</option>
                    </select>
                </div>
                <div>
                    <label for="cycle-amount" class="block text-sm font-medium text-white mb-2">Cycle Amount (Phase:State Ratio)</label>
                    <select id="cycle-amount" class="w-full bg-gray-700 border-gray-600 text-white rounded p-2 h-10">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                        <option value="7">7</option>
                        <option value="8">8</option>
                        <option value="9">9</option>
                        <option value="10">10</option>
                        <option value="11">11</option>
                        <option value="12">12</option>
                    </select>
                </div>
            </div>
            <!-- Checkboxes -->
            <div class="mt-4 grid grid-cols-1 md:grid-cols-3 gap-4">
                <div class="flex items-center">
                    <input id="show-phase-trail" type="checkbox" class="h-4 w-4 text-blue-500 bg-gray-700 border-gray-600 rounded focus:ring-blue-600">
                    <label for="show-phase-trail" class="ml-2 block text-sm font-medium text-white">Show Phase Trail</label>
                </div>
                <!-- Checkbox for -q -->
                <div class="flex items-center">
                    <input id="show-negative-q" type="checkbox" class="h-4 w-4 text-blue-500 bg-gray-700 border-gray-600 rounded focus:ring-blue-600">
                    <label for="show-negative-q" class="ml-2 block text-sm font-medium text-white">Show $-q$ (2:1 Twist)</label>
                </div>
                <!-- Checkbox for q-inverse -->
                <div class="flex items-center">
                    <input id="show-inverse-q" type="checkbox" class="h-4 w-4 text-blue-500 bg-gray-700 border-gray-600 rounded focus:ring-blue-600">
                    <label for="show-inverse-q" class="ml-2 block text-sm font-medium text-white">Show $q^{-1}$ (Inverse Rotation)</label>
                </div>
            </div>
            
            <!-- Value Readouts -->
            <div class="mt-6 grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                <div>
                    <span class="text-xs text-gray-400 uppercase">Quaternion $q$</span>
                    <p id="q-value" class="text-sm font-mono text-white"></p>
                </div>
                <div>
                    <span class="text-xs text-gray-400 uppercase">Axis $u$</span>
                    <p id="u-value" class="text-sm font-mono text-white"></p>
                </div>
                <div>
                    <span class="text-xs text-gray-400 uppercase">Angle $\theta$</span>
                    <p id="theta-value" class="text-sm font-mono text-white"></p>
                </div>
                <div>
                    <span class="text-xs text-gray-400 uppercase">3:1 Compression $\chi(q)$</span>
                    <p id="chi-value" class="text-sm font-mono text-white"></p>
                </div>
            </div>
        </div>

        <!-- Visualizations Grid -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            
            <!-- Step 1 & 2: S³ -> S² (3D View) -->
            <div class="viz-container">
                <h2 class="text-xl font-semibold text-white mb-2">Step 1 & 2: S³ &rarr; S² (3D View)</h2>
                <p class="text-sm text-gray-400 mb-4">
                    The 3D sphere (S²). <strong class="text-cyan-400">Cyan/Red</strong> is $q$. <strong class="text-orange-400">Orange</strong> is $-q$ (same Hopf point). <strong class="text-purple-400">Purple</strong> is $q^{-1}$ (inverse).
                </p>
                <div id="viz-3d-container" class="h-96 rounded"></div>
            </div>

            <!-- Step 1 & 2: S³ -> S² (2D Trace) -->
            <div class="viz-container">
                <h2 class="text-xl font-semibold text-white mb-2">Step 1 & 2: S³ &rarr; S² (2D Trace)</h2>
                <p class="text-sm text-gray-400 mb-4">
                    A 2D plot tracing the full path of the <strong class="text-red-400">Red</strong> Hopf point (H(<i>q</i>)) as $t$ goes from 0 to 1. Change the path algorithm to see different traces.
                </p>
                <svg id="viz-trace-svg" viewBox="-1.1 -1.1 2.2 2.2" class="h-96 w-full"></svg>
            </div>

            <!-- Hopf Fibration (Torus) -->
            <div class="viz-container">
                <h2 class="text-xl font-semibold text-white mb-2">Hopf Fibration (Torus)</h2>
                <p class="text-sm text-gray-400 mb-4">
                    The <strong class="text-cyan-400">Cyan</strong> line points from the origin to the selected fiber (the <strong class="text-red-400">Red</strong> dot on the green loop). The <strong class="text-yellow-400">Yellow</strong> dot shows the current "phase" on that fiber, corresponding to the S¹ Fiber view.
                </p>
                <div id="viz-torus-container" class="h-96 rounded"></div>
            </div>

            <!-- Hopf Fibration (S¹ Fiber) -->
            <div class="viz-container">
                <h2 class="text-xl font-semibold text-white mb-2">Hopf Fibration (S¹ Fiber)</h2>
                <p class="text-sm text-gray-400 mb-4">
                    This is the "loop" (an $S^1$ fiber). The <strong class="text-yellow-400">Yellow</strong> dot's "phase" is now locked to the $t$ parameter and matches the <strong class="text-yellow-400">Yellow</strong> dot on the torus.
                </p>
                <svg id="viz-fiber-svg" viewBox="-1.2 -1.2 2.4 2.4" class="h-96 w-full"></svg>
            </div>
            
            <!-- Step 3: S² -> Disk (Lambert) -->
            <div class="viz-container">
                <h2 class="text-xl font-semibold text-white mb-2">Step 3: S² &rarr; Disk</h2>
                <p class="text-sm text-gray-400 mb-4">
                    Lambert Azimuthal Equal-Area projection. The <strong class="text-red-400">Red</strong> dot is $q$. <strong class="text-purple-400">Purple</strong> is $q^{-1}$. Color is mapped to $\theta$.
                </p>
                <svg id="viz-disk-svg" viewBox="-1.5 -1.5 3 3" class="h-96 w-full"></svg>
            </div>
            
            <!-- Step 4: Disk -> Square -->
            <div class="viz-container">
                <h2 class="text-xl font-semibold text-white mb-2">Step 4: Disk &rarr; Square</h2>
                <p class="text-sm text-gray-400 mb-4">
                    Concentric squares transform. The disk (D²) is warped to fill a unit square [0,1]². This packs all 3D orientations into a 2D map.
                </p>
                <svg id="viz-square-svg" viewBox="-0.1 -0.1 1.2 1.2" class="h-96 w-full"></svg>
            </div>

        </div>
    </div>

    <!-- Main JavaScript Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let sphereMesh, axisArrow, axisArrowNeg, axisArrowInv, hopfPoint, hopfPointNeg, hopfPointInv;
        
        let sceneTorus, cameraTorus, rendererTorus, torusMesh, controlsTorus, poloidalLoop;
        let fiberIntersectionPoint, fiberPhasePoint, centerToFiberLine, fiberToPhaseLine;
        let phaseTrailLine, phaseTrailGeometry;
        let phaseTrailPoints = [];
        const MAX_TRAIL_POINTS = 500;

        let diskSVG, diskPoint, diskPointNeg, diskPointInv;
        let squareSVG, squarePoint, squarePointNeg, squarePointInv;
        let traceSVG, tracePath, tracePoint;
        let fiberSVG, fiberDot;

        let showNegativeQ = false;
        let showInverseQ = false;
        let showPhaseTrail = false;
        let fullHopfPath = [];
        
        const majorRadius = 0.8;
        const minorRadius = 0.3;

        // --- Initialization ---
        
        function init() {
            init3D();
            initTorus();
            init2D();
            initTrace();
            initFiber();
            calculateFullHopfPath();
            drawTracePath();
            addEventListeners();
            updateVisualizations(0);
            animate();
        }

        function init3D() {
            const container = document.getElementById('viz-3d-container');
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 1.8;
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            scene.add(new THREE.AmbientLight(0xaaaaaa));
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(1, 1, 1);
            scene.add(light);

            const sphereGeo = new THREE.SphereGeometry(1, 64, 64);
            const sphereMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.2,
                wireframe: true
            });
            sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);
            scene.add(sphereMesh);
            
            const hopfGeo = new THREE.SphereGeometry(0.04, 16, 16);
            
            // Hopf Point (q) (Red)
            const hopfMatRed = new THREE.MeshBasicMaterial({ color: 0xf87171 }); // red-400
            hopfPoint = new THREE.Mesh(hopfGeo, hopfMatRed);
            scene.add(hopfPoint);

            // Hopf Point (-q) (Red, but will be same pos as q)
            hopfPointNeg = new THREE.Mesh(hopfGeo, hopfMatRed);
            hopfPointNeg.visible = false;
            scene.add(hopfPointNeg);
            
            // Hopf Point (q-inv) (Purple)
            const hopfMatPurple = new THREE.MeshBasicMaterial({ color: 0xc084fc }); // purple-400
            hopfPointInv = new THREE.Mesh(hopfGeo, hopfMatPurple);
            hopfPointInv.visible = false;
            scene.add(hopfPointInv);

            // Axis Arrow (q) (Cyan)
            axisArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 1.2, 0x22d3ee, 0.1, 0.05); // cyan-400
            scene.add(axisArrow);

            // Axis Arrow (-q) (Orange)
            axisArrowNeg = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 1.2, 0xfb923c, 0.1, 0.05); // orange-400
            axisArrowNeg.visible = false;
            scene.add(axisArrowNeg);
            
            // Axis Arrow (q-inv) (Purple)
            axisArrowInv = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 1.2, 0xc084fc, 0.1, 0.05); // purple-400
            axisArrowInv.visible = false;
            scene.add(axisArrowInv);

            window.addEventListener('resize', () => {
                if (container.clientWidth === 0 || container.clientHeight === 0) return;
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }
        
        function initTorus() {
            const container = document.getElementById('viz-torus-container');

            sceneTorus = new THREE.Scene();
            cameraTorus = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            cameraTorus.position.z = 2.2;
            
            rendererTorus = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            rendererTorus.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(rendererTorus.domElement);

            controlsTorus = new OrbitControls(cameraTorus, rendererTorus.domElement);
            controlsTorus.enableDamping = true;
            controlsTorus.dampingFactor = 0.05;

            sceneTorus.add(new THREE.AmbientLight(0xaaaaaa));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1);
            sceneTorus.add(directionalLight);
            
            const torusGeo = new THREE.TorusGeometry(majorRadius, minorRadius, 20, 75);
            const torusMat = new THREE.MeshStandardMaterial({
                color: 0x3b82f6, // blue-500
                wireframe: true,
                transparent: true,
                opacity: 0.8
            });
            torusMesh = new THREE.Mesh(torusGeo, torusMat);
            sceneTorus.add(torusMesh);

            const nodeGeo = new THREE.SphereGeometry(0.1, 16, 16);
            const nodeMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); // White
            const intersectionNode = new THREE.Mesh(nodeGeo, nodeMat);
            sceneTorus.add(intersectionNode);

            const toroidalMat = new THREE.LineBasicMaterial({ color: 0x4ade80, linewidth: 3 }); // green-400
            const toroidalPoints = [];
            for (let i = 0; i <= 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                toroidalPoints.push(
                    new THREE.Vector3(
                        majorRadius * Math.cos(angle),
                        majorRadius * Math.sin(angle),
                        0
                    )
                );
            }
            const toroidalGeo = new THREE.BufferGeometry().setFromPoints(toroidalPoints);
            const toroidalLoop = new THREE.Line(toroidalGeo, toroidalMat);
            sceneTorus.add(toroidalLoop);

            const poloidalMat = new THREE.LineBasicMaterial({ color: 0xfde047, linewidth: 3 }); // yellow-400
            const poloidalPoints = [];
            for (let i = 0; i <= 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                poloidalPoints.push(
                    new THREE.Vector3(
                        majorRadius + minorRadius * Math.cos(angle),
                        0,
                        minorRadius * Math.sin(angle)
                    )
                );
            }
            const poloidalGeo = new THREE.BufferGeometry().setFromPoints(poloidalPoints);
            poloidalLoop = new THREE.Line(poloidalGeo, poloidalMat);
            sceneTorus.add(poloidalLoop);

            // Red Node (Fiber Intersection)
            const fiberIntGeo = new THREE.SphereGeometry(0.06, 16, 16);
            const fiberIntMat = new THREE.MeshBasicMaterial({ color: 0xf87171 }); // red-400
            fiberIntersectionPoint = new THREE.Mesh(fiberIntGeo, fiberIntMat);
            sceneTorus.add(fiberIntersectionPoint);

            // Yellow Node (Fiber Phase)
            const fiberPhaseGeo = new THREE.SphereGeometry(0.05, 16, 16);
            const fiberPhaseMat = new THREE.MeshBasicMaterial({ color: 0xfde047 }); // yellow-400
            fiberPhasePoint = new THREE.Mesh(fiberPhaseGeo, fiberPhaseMat);
            sceneTorus.add(fiberPhasePoint);

            // Cyan Line (Center to Fiber)
            const centerLineMat = new THREE.LineBasicMaterial({ color: 0x22d3ee }); // cyan-400
            const centerLineGeo = new THREE.BufferGeometry();
            centerLineGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(2 * 3), 3));
            centerToFiberLine = new THREE.Line(centerLineGeo, centerLineMat);
            sceneTorus.add(centerToFiberLine);

            // White Line (Fiber to Phase)
            const phaseLineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 });
            const phaseLineGeo = new THREE.BufferGeometry();
            phaseLineGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(2 * 3), 3));
            fiberToPhaseLine = new THREE.Line(phaseLineGeo, phaseLineMat);
            sceneTorus.add(fiberToPhaseLine);
            
            // Yellow Trail Line (Phase Trail)
            phaseTrailGeometry = new THREE.BufferGeometry();
            phaseTrailGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(MAX_TRAIL_POINTS * 3), 3));
            const trailMat = new THREE.LineBasicMaterial({ color: 0xfde047, transparent: true, opacity: 0.6 });
            phaseTrailLine = new THREE.Line(phaseTrailGeometry, trailMat);
            phaseTrailLine.visible = false;
            sceneTorus.add(phaseTrailLine);

            window.addEventListener('resize', () => {
                if (container.clientWidth === 0 || container.clientHeight === 0) return;
                cameraTorus.aspect = container.clientWidth / container.clientHeight;
                cameraTorus.updateProjectionMatrix();
                rendererTorus.setSize(container.clientWidth, container.clientHeight);
            });
        }

        function init2D() {
            diskSVG = document.getElementById('viz-disk-svg');
            squareSVG = document.getElementById('viz-square-svg');
            
            diskSVG.innerHTML = '<circle cx="0" cy="0" r="1.414" fill="#1f2937" stroke="#4b5563" stroke-width="0.01" />';
            squareSVG.innerHTML = '<rect x="0" y="0" width="1" height="1" fill="#1f2937" stroke="#4b5563" stroke-width="0.005" />';
            
            // q Point (Red)
            diskPoint = document.createElementNS("http://www.w3.org/2000/svg", 'circle');
            diskPoint.setAttribute('r', '0.05');
            diskPoint.setAttribute('fill', '#f87171'); // red-400
            squarePoint = document.createElementNS("http://www.w3.org/2000/svg", 'circle');
            squarePoint.setAttribute('r', '0.015');
            squarePoint.setAttribute('fill', '#f87171'); // red-400
            
            // -q Point (Transparent Red)
            diskPointNeg = diskPoint.cloneNode();
            diskPointNeg.setAttribute('opacity', '0.5');
            squarePointNeg = squarePoint.cloneNode();
            squarePointNeg.setAttribute('opacity', '0.5');
            
            // q-inv Point (Purple)
            diskPointInv = diskPoint.cloneNode();
            diskPointInv.setAttribute('fill', '#c084fc'); // purple-400
            squarePointInv = squarePoint.cloneNode();
            squarePointInv.setAttribute('fill', '#c084fc'); // purple-400
            
            diskSVG.appendChild(diskPoint);
            diskSVG.appendChild(diskPointNeg);
            diskSVG.appendChild(diskPointInv);
            squareSVG.appendChild(squarePoint);
            squareSVG.appendChild(squarePointNeg);
            squareSVG.appendChild(squarePointInv);
        }

        function initTrace() {
            traceSVG = document.getElementById('viz-trace-svg');
            traceSVG.innerHTML = '<rect x="-1" y="-1" width="2" height="2" fill="none" stroke="#4b5563" stroke-width="0.01" />';

            tracePath = document.createElementNS("http://www.w3.org/2000/svg", 'path');
            tracePath.setAttribute('fill', 'none');
            tracePath.setAttribute('stroke', '#60a5fa'); // blue-400
            tracePath.setAttribute('stroke-width', '0.01');
            traceSVG.appendChild(tracePath);

            tracePoint = document.createElementNS("http://www.w3.org/2000/svg", 'circle');
            tracePoint.setAttribute('r', '0.04');
            tracePoint.setAttribute('fill', '#f87171'); // red-400
            traceSVG.appendChild(tracePoint);
        }
        
        function initFiber() {
            fiberSVG = document.getElementById('viz-fiber-svg');
            fiberSVG.innerHTML = '<circle cx="0" cy="0" r="1" fill="none" stroke="#4b5563" stroke-width="0.02" />';
            
            fiberDot = document.createElementNS("http://www.w3.org/2000/svg", 'circle');
            fiberDot.setAttribute('r', '0.1');
            fiberDot.setAttribute('fill', '#fde047'); // yellow-400
            fiberSVG.appendChild(fiberDot);
        }

        function addEventListeners() {
            document.getElementById('param-slider').addEventListener('input', (e) => {
                updateVisualizations(parseFloat(e.target.value));
            });
            document.getElementById('show-negative-q').addEventListener('change', (e) => {
                showNegativeQ = e.target.checked;
                updateVisualizations(parseFloat(document.getElementById('param-slider').value));
            });
            document.getElementById('show-inverse-q').addEventListener('change', (e) => {
                showInverseQ = e.target.checked;
                updateVisualizations(parseFloat(document.getElementById('param-slider').value));
            });
            document.getElementById('show-phase-trail').addEventListener('change', (e) => {
                showPhaseTrail = e.target.checked;
                phaseTrailLine.visible = showPhaseTrail;
                if (!showPhaseTrail) {
                    phaseTrailPoints = [];
                    updatePhaseTrail();
                }
            });
            document.getElementById('animation-mode').addEventListener('change', (e) => {
                if (e.target.value === 'off') {
                    phaseTrailPoints = [];
                    updatePhaseTrail();
                }
            });
            document.getElementById('path-selector').addEventListener('change', (e) => {
                calculateFullHopfPath();
                drawTracePath();
                updateVisualizations(parseFloat(document.getElementById('param-slider').value));
            });
        }
        
        // --- Animation Loop ---

        function animate(time) {
            time = time || 0;
            requestAnimationFrame(animate);
            
            let t;
            const animationMode = document.getElementById('animation-mode').value;
            const slider = document.getElementById('param-slider');
            const cycleAmount = parseInt(document.getElementById('cycle-amount').value, 10) || 1;

            if (animationMode === 'oscillate') {
                slider.disabled = true;
                t = (Math.sin(time * 0.0005) + 1) / 2;
                slider.value = t;
                updateVisualizations(t); 
            } else if (animationMode === 'loop') {
                slider.disabled = true;
                t = (time * 0.0005) % 1.0; // Use a constant loop speed
                slider.value = t;
                updateVisualizations(t);
            } else { // 'off'
                slider.disabled = false;
                t = parseFloat(slider.value);
                // updateVisualizations is only called by slider listener, so we just use t for phase calcs
            }
            
            if (controls) controls.update();
            if (controlsTorus) controlsTorus.update(); 
            if (renderer && scene && camera) renderer.render(scene, camera);
            if (torusMesh && rendererTorus && sceneTorus && cameraTorus) {
                rendererTorus.render(sceneTorus, cameraTorus);
            }
            
            const phase = (t * cycleAmount * Math.PI * 2) % (Math.PI * 2);

            if (fiberDot) {
                fiberDot.setAttribute('cx', Math.cos(phase));
                fiberDot.setAttribute('cy', Math.sin(phase));
            }

            if (fiberPhasePoint && fiberToPhaseLine && fiberIntersectionPoint) {
                const poloidalAngle = t * Math.PI * 2;
                
                const r_cos_phase = minorRadius * Math.cos(phase);
                const r_sin_phase = minorRadius * Math.sin(phase);
                const R_plus_rcos = majorRadius + r_cos_phase;
                
                const cos_poloidal = Math.cos(poloidalAngle);
                const sin_poloidal = Math.sin(poloidalAngle);
                
                fiberPhasePoint.position.set(
                    R_plus_rcos * cos_poloidal,
                    R_plus_rcos * sin_poloidal,
                    r_sin_phase
                );

                const yellowNodePos = fiberPhasePoint.position;
                
                if (showPhaseTrail && animationMode !== 'off') {
                    if (!isNaN(yellowNodePos.x)) {
                        phaseTrailPoints.push(yellowNodePos.x, yellowNodePos.y, yellowNodePos.z);
                        if (phaseTrailPoints.length > MAX_TRAIL_POINTS * 3) {
                            phaseTrailPoints.splice(0, 3); // Remove oldest point
                        }
                        updatePhaseTrail();
                    }
                }

                const linePos = fiberToPhaseLine.geometry.attributes.position;
                const redNodePos = fiberIntersectionPoint.position;
                // const yellowNodePos = fiberPhasePoint.position; // <-- This was the duplicate declaration
                
                if (!isNaN(redNodePos.x) && !isNaN(yellowNodePos.x)) {
                    linePos.setXYZ(0, redNodePos.x, redNodePos.y, redNodePos.z);
                    linePos.setXYZ(1, yellowNodePos.x, yellowNodePos.y, yellowNodePos.z);
                    linePos.needsUpdate = true;
                    fiberToPhaseLine.geometry.computeBoundingSphere(); // This is safe now
                }
            }
        }

        // --- Refactored State Logic ---

        function getState(t) {
            const pathType = document.getElementById('path-selector').value;
            let q;
            const angle = t * Math.PI * 2;

            switch (pathType) {
                case 'simple-twist': {
                    const rotAngle = t * Math.PI;
                    q = {
                        w: Math.cos(rotAngle),
                        x: 0,
                        y: 0,
                        z: Math.sin(rotAngle)
                    };
                    break;
                }
                
                case 'lissajous': {
                    const a = 3;
                    const b = 2;
                    q = {
                        w: Math.cos(angle / 2),
                        x: Math.sin(angle / 2) * Math.sin(a * angle),
                        y: Math.sin(angle / 2) * Math.sin(b * angle),
                        z: Math.sin(angle / 2) * Math.cos(angle)
                    };
                    break;
                }

                case 'trefoil-knot': {
                    const p = 2;
                    const q_p = 3;
                    const balance = 1.0 / Math.sqrt(2.0);
                    q = {
                        w: balance * Math.cos(p * angle),
                        x: balance * Math.sin(p * angle),
                        y: balance * Math.cos(q_p * angle),
                        z: balance * Math.sin(q_p * angle)
                    };
                    break;
                }
                
                case 'knot':
                default: {
                    q = {
                        w: Math.cos(angle * 0.5),
                        x: Math.sin(angle * 0.5) * Math.cos(angle * 2),
                        y: Math.sin(angle * 0.5) * Math.sin(angle * 2),
                        z: Math.sin(angle * 0.5) * Math.cos(angle)
                    };
                    break;
                }
            }

            const norm = Math.sqrt(q.w*q.w + q.x*q.x + q.y*q.y + q.z*q.z);
            if (norm > 1e-6) {
                 q.w /= norm; q.x /= norm; q.y /= norm; q.z /= norm;
            } else {
                 q = { w: 1, x: 0, y: 0, z: 0 };
            }
            
            const qNeg = { w: -q.w, x: -q.x, y: -q.y, z: -q.z };
            // q-inverse is (w, -x, -y, -z) for a unit quaternion
            const qInv = { w: q.w, x: -q.x, y: -q.y, z: -q.z };
            
            return { q, qNeg, qInv };
        }

        function getDerivatives(q) {
            const theta = 2 * Math.acos(Math.max(-1, Math.min(1, q.w)));
            const sinHalfTheta = Math.sin(theta / 2);
            let u;
            if (Math.abs(sinHalfTheta) < 1e-6) {
                u = { x: 0, y: 0, z: 1 };
            } else {
                u = {
                    x: q.x / sinHalfTheta,
                    y: q.y / sinHalfTheta,
                    z: q.z / sinHalfTheta
                };
            }
            
            const hopf = {
                x: 2 * (q.x * q.z + q.w * q.y),
                y: 2 * (q.y * q.z - q.w * q.x),
                z: 1 - 2 * (q.x * q.x + q.y * q.y)
            };
            
            const vecMag = Math.sqrt(q.x*q.x + q.y*q.y + q.z*q.z);
            const chi = Math.atan2(vecMag, q.w);
            
            const lambda = Math.atan2(hopf.y, hopf.x);
            const phi = Math.asin(Math.max(-1, Math.min(1, hopf.z)));
            
            const rho = Math.sqrt(2) * Math.sin(Math.PI / 4 - phi / 2);
            const disk = {
                u: rho * Math.cos(lambda),
                v: rho * Math.sin(lambda)
            };
            
            const u2 = disk.u * disk.u;
            const v2 = disk.v * disk.v;
            const u_sq = disk.u * Math.sqrt(Math.max(0, 1 - v2 / 2));
            const v_sq = disk.v * Math.sqrt(Math.max(0, 1 - u2 / 2));
            
            const square = {
                x: isNaN(u_sq) ? 0 : u_sq,
                y: isNaN(v_sq) ? 0 : v_sq
            };
            
            const square01 = {
                x: (square.x + 1) / 2,
                y: (square.y + 1) / 2
            };
            
            return { u, theta, hopf, chi, disk, square, square01 };
        }
        
        // --- Full Path Calculation ---

        function calculateFullHopfPath() {
            fullHopfPath = [];
            const steps = 200;
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const { q } = getState(t);
                const { hopf } = getDerivatives(q);
                fullHopfPath.push({ x: hopf.x, z: hopf.z });
            }
        }
        
        function drawTracePath() {
            if (!tracePath || fullHopfPath.length === 0) return;
            let d = `M ${fullHopfPath[0].x} ${-fullHopfPath[0].z}`;
            for (let i = 1; i < fullHopfPath.length; i++) {
                d += ` L ${fullHopfPath[i].x} ${-fullHopfPath[i].z}`;
            }
            tracePath.setAttribute('d', d);
        }

        // --- Utility Functions ---

        function updatePhaseTrail() {
            if (!phaseTrailLine) return;
            const positions = phaseTrailLine.geometry.attributes.position.array;
            
            for (let i = 0; i < phaseTrailPoints.length; i++) {
                positions[i] = phaseTrailPoints[i];
            }
            
            // fill remaining buffer with NaN to stop drawing
            for (let i = phaseTrailPoints.length; i < positions.length; i++) {
                positions[i] = NaN;
            }

            phaseTrailLine.geometry.attributes.position.needsUpdate = true;
            phaseTrailLine.geometry.setDrawRange(0, phaseTrailPoints.length / 3);
            phaseTrailLine.geometry.computeBoundingSphere();
        }

        // --- Main Update Function ---
        
        function updateVisualizations(t) {
            const { q, qNeg, qInv } = getState(t);
            const { u, theta, hopf, chi, disk, square, square01 } = getDerivatives(q);
            const { u: uNeg, hopf: hopfNeg, disk: diskNeg, square01: square01Neg } = getDerivatives(qNeg);
            const { u: uInv, hopf: hopfInv, disk: diskInv, square01: square01Inv } = getDerivatives(qInv);
            
            // 1. Update Text Readouts
            document.getElementById('q-value').textContent = `(${q.w.toFixed(2)}, ${q.x.toFixed(2)}, ${q.y.toFixed(2)}, ${q.z.toFixed(2)})`;
            document.getElementById('u-value').textContent = `(${u.x.toFixed(2)}, ${u.y.toFixed(2)}, ${u.z.toFixed(2)})`;
            document.getElementById('theta-value').textContent = theta.toFixed(3);
            document.getElementById('chi-value').textContent = chi.toFixed(3);
            
            // 2. Update 3D (S²)
            hopfPoint.position.set(hopf.x, hopf.y, hopf.z);
            axisArrow.setDirection(new THREE.Vector3(u.x, u.y, u.z));
            
            hopfPointNeg.position.set(hopfNeg.x, hopfNeg.y, hopfNeg.z);
            axisArrowNeg.setDirection(new THREE.Vector3(uNeg.x, uNeg.y, uNeg.z));
            
            hopfPointInv.position.set(hopfInv.x, hopfInv.y, hopfInv.z);
            axisArrowInv.setDirection(new THREE.Vector3(uInv.x, uInv.y, uInv.z));

            // 2.1 Update Torus Elements
            if (poloidalLoop && fiberIntersectionPoint && centerToFiberLine) {
                const poloidalAngle = t * Math.PI * 2;
                poloidalLoop.rotation.z = poloidalAngle;

                fiberIntersectionPoint.position.set(
                    majorRadius * Math.cos(poloidalAngle),
                    majorRadius * Math.sin(poloidalAngle),
                    0
                );

                const linePos = centerToFiberLine.geometry.attributes.position;
                const redNodePos = fiberIntersectionPoint.position;
                if (!isNaN(redNodePos.x)) {
                    linePos.setXYZ(0, 0, 0, 0);
                    linePos.setXYZ(1, redNodePos.x, redNodePos.y, redNodePos.z);
                    linePos.needsUpdate = true;
                    centerToFiberLine.geometry.computeBoundingSphere(); // Safe
                }
            }

            // 3. Update 2D Trace
            tracePoint.setAttribute('cx', hopf.x);
            tracePoint.setAttribute('cy', -hopf.z);
            
            // 4. Update 2D (Disk)
            const color = `hsl(${theta * (180 / Math.PI)}, 80%, 60%)`;
            
            diskPoint.setAttribute('cx', disk.u);
            diskPoint.setAttribute('cy', -disk.v);
            diskPoint.setAttribute('fill', color);
            
            diskPointNeg.setAttribute('cx', diskNeg.u);
            diskPointNeg.setAttribute('cy', -diskNeg.v);
            diskPointNeg.setAttribute('fill', color);
            
            diskPointInv.setAttribute('cx', diskInv.u);
            diskPointInv.setAttribute('cy', -diskInv.v);
            diskPointInv.setAttribute('fill', color);
            
            // 5. Update 2D (Square)
            squarePoint.setAttribute('cx', square01.x);
            squarePoint.setAttribute('cy', 1 - square01.y);
            squarePoint.setAttribute('fill', color);
            
            squarePointNeg.setAttribute('cx', square01Neg.x);
            squarePointNeg.setAttribute('cy', 1 - square01Neg.y);
            squarePointNeg.setAttribute('fill', color);
            
            squarePointInv.setAttribute('cx', square01Inv.x);
            squarePointInv.setAttribute('cy', 1 - square01Inv.y);
            squarePointInv.setAttribute('fill', color);

            // 6. Update Visibility
            axisArrowNeg.visible = showNegativeQ;
            hopfPointNeg.visible = showNegativeQ; // Note: this will just overlap hopfPoint
            diskPointNeg.style.display = showNegativeQ ? 'block' : 'none';
            squarePointNeg.style.display = showNegativeQ ? 'block' : 'none';
            
            axisArrowInv.visible = showInverseQ;
            hopfPointInv.visible = showInverseQ;
            diskPointInv.style.display = showInverseQ ? 'block' : 'none';
            squarePointInv.style.display = showInverseQ ? 'block' : 'none';
        }

        // --- Start ---
        init();
        
    </script>
</body>
</html>

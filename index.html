<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bifilar Coil with Toroidal Field Control</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js for 3D visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .three-container {
            height: 500px;
            background-color: #111827; /* bg-gray-900 */
            border-radius: 0.75rem;
            position: relative;
            overflow: hidden;
            cursor: move;
        }
        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 8px;
            background: #4b5563; border-radius: 5px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 20px; height: 20px;
            background: #3b82f6; cursor: pointer; border-radius: 50%;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px; height: 20px;
            background: #3b82f6; cursor: pointer; border-radius: 50%;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto max-w-4xl px-4 py-8 md:py-12">

        <header class="text-center mb-10">
            <h1 class="text-4xl font-bold text-gray-900">Bifilar Coil Field Visualization</h1>
            <p class="text-xl text-indigo-600 font-semibold mt-2">Single Emitter Simulation</p>
        </header>

        <main class="bg-white p-6 md:p-8 rounded-2xl shadow-lg">
            <section id="diagram">
                <h2 class="text-2xl font-bold mb-4 border-b pb-2">Interactive Simulation</h2>
                <p class="mb-4 text-gray-600">This simulation visualizes a toroidal field generated by a single bifilar coil. An invisible plane filters the fields. Use the controls to adjust the fields and the filter plane's orientation. <br><b>Camera Controls:</b> Left-drag to rotate, Right-drag to pan, Scroll to zoom.</p>
                <div id="simulation-container" class="three-container"></div>
                <div class="mt-4 p-4 bg-gray-100 rounded-lg space-y-6">
                    <!-- General Settings -->
                    <div class="border-b border-gray-300 pb-4">
                        <h3 class="font-semibold text-gray-700 mb-2 text-lg">General Settings</h3>
                        <div>
                           <label for="pulse-frequency" class="font-semibold text-gray-700">Pulse Frequency: <span id="frequency-readout" class="font-mono text-indigo-600">1.0</span></label>
                           <input type="range" id="pulse-frequency" min="0.1" max="5" step="0.1" value="1" class="w-full mt-2">
                        </div>
                    </div>
                    <!-- Red Field Settings -->
                     <div class="border-b border-gray-300 pb-4">
                        <h3 class="font-semibold text-red-600 mb-2 text-lg">Red Field Settings</h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                             <div>
                               <label for="red-amplitude">Amplitude: <span id="red-amplitude-readout" class="font-mono">4.0</span></label>
                               <input type="range" id="red-amplitude" min="2" max="6" step="0.1" value="4.0" class="w-full mt-2">
                            </div>
                            <div>
                               <label for="red-size">Size: <span id="red-size-readout" class="font-mono">0.8</span></label>
                               <input type="range" id="red-size" min="0.1" max="2" step="0.1" value="0.8" class="w-full mt-2">
                            </div>
                            <div>
                               <label for="red-offset">Offset: <span id="red-offset-readout" class="font-mono">0.0</span></label>
                               <input type="range" id="red-offset" min="-3" max="3" step="0.1" value="0" class="w-full mt-2">
                            </div>
                        </div>
                    </div>
                     <!-- Blue Field Settings -->
                     <div class="border-b border-gray-300 pb-4">
                        <h3 class="font-semibold text-blue-600 mb-2 text-lg">Blue Field Settings</h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                             <div>
                               <label for="blue-amplitude">Amplitude: <span id="blue-amplitude-readout" class="font-mono">1.3</span></label>
                               <input type="range" id="blue-amplitude" min="0.5" max="4" step="0.1" value="1.3" class="w-full mt-2">
                            </div>
                            <div>
                               <label for="blue-size">Size: <span id="blue-size-readout" class="font-mono">0.3</span></label>
                               <input type="range" id="blue-size" min="0.1" max="1" step="0.05" value="0.3" class="w-full mt-2">
                            </div>
                             <div>
                               <label for="blue-offset">Offset: <span id="blue-offset-readout" class="font-mono">0.0</span></label>
                               <input type="range" id="blue-offset" min="-3" max="3" step="0.1" value="0" class="w-full mt-2">
                            </div>
                        </div>
                    </div>
                     <!-- Filter Plane Settings -->
                     <div class="border-b border-gray-300 pb-4">
                        <h3 class="font-semibold text-gray-700 mb-2 text-lg">Filter Plane Orientation</h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-x-6 gap-y-2">
                            <div>
                                <label for="plane-rot-x">X-Axis</label>
                                <input type="range" id="plane-rot-x" min="-180" max="180" value="0">
                            </div>
                            <div>
                                <label for="plane-rot-y">Y-Axis</label>
                                <input type="range" id="plane-rot-y" min="-180" max="180" value="0">
                            </div>
                             <div>
                                <label for="plane-rot-z">Z-Axis</label>
                                <input type="range" id="plane-rot-z" min="-180" max="180" value="0">
                            </div>
                        </div>
                    </div>
                    <!-- System Orientation Settings -->
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-2 text-lg">System Orientation</h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-x-6 gap-y-2">
                            <div>
                                <label for="rot-x">X-Axis</label>
                                <input type="range" id="rot-x" min="-180" max="180" value="0">
                            </div>
                            <div>
                                <label for="rot-y">Y-Axis</label>
                                <input type="range" id="rot-y" min="-180" max="180" value="0">
                            </div>
                             <div>
                                <label for="rot-z">Z-Axis</label>
                                <input type="range" id="rot-z" min="-180" max="180" value="0">
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </main>
        
        <footer class="text-center mt-10 text-sm text-gray-500">
            <p>Project documentation. Last updated: <span id="date"></span>.</p>
        </footer>
    </div>

    <script>
        window.addEventListener('DOMContentLoaded', () => {
            // --- Utility Functions ---
            const toRadians = (degrees) => degrees * (Math.PI / 180);

            function addCameraControls(camera, domElement) {
                const target = new THREE.Vector3(0, 0, 0);
                let isRotating = false;
                let isPanning = false;
                let previousMousePosition = { x: 0, y: 0 };
                const panSpeed = 0.01;
                const zoomSpeed = 0.1;
                function onPointerDown(e) {
                    if (e.button === 0) isRotating = true;
                    if (e.button === 2) isPanning = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
                function onPointerUp(e) {
                    isRotating = false;
                    isPanning = false;
                }
                function onPointerMove(e) {
                    const deltaMove = { x: e.clientX - previousMousePosition.x, y: e.clientY - previousMousePosition.y };
                    if (isRotating) {
                        const deltaRotationQuaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(toRadians(deltaMove.y * 0.5), toRadians(deltaMove.x * 0.5), 0, 'YXZ'));
                        const offset = new THREE.Vector3().subVectors(camera.position, target);
                        offset.applyQuaternion(deltaRotationQuaternion);
                        camera.position.copy(target).add(offset);
                        camera.lookAt(target);
                    } else if (isPanning) {
                        const panOffset = new THREE.Vector3();
                        const v = new THREE.Vector3().subVectors(camera.position, target).normalize();
                        const u = new THREE.Vector3().crossVectors(camera.up, v).normalize();
                        panOffset.add(u.multiplyScalar(-deltaMove.x * panSpeed));
                        panOffset.add(camera.up.clone().multiplyScalar(deltaMove.y * panSpeed));
                        camera.position.add(panOffset);
                        target.add(panOffset);
                    }
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
                function onWheel(e) {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 1 : -1;
                    const direction = new THREE.Vector3().subVectors(target, camera.position).normalize();
                    camera.position.add(direction.multiplyScalar(delta * zoomSpeed));
                }
                domElement.addEventListener('contextmenu', e => e.preventDefault());
                domElement.addEventListener('pointerdown', onPointerDown);
                domElement.addEventListener('pointerup', onPointerUp);
                domElement.addEventListener('pointermove', onPointerMove);
                domElement.addEventListener('wheel', onWheel, { passive: false });
            }

            // --- Main Simulation Setup ---
            function initVisualization() {
                const container = document.getElementById('simulation-container');
                if (!container) return;

                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.set(0, 5, 12);
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                container.appendChild(renderer.domElement);
                
                scene.add(new THREE.AmbientLight(0xffffff, 0.7));
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 10, 7.5);
                scene.add(dirLight);

                const masterCoilSystem = new THREE.Group();
                scene.add(masterCoilSystem);
                addCameraControls(camera, container);

                // --- DOM Element Refs ---
                const pulseSlider = document.getElementById('pulse-frequency'), pulseReadout = document.getElementById('frequency-readout');
                const redAmplitudeSlider = document.getElementById('red-amplitude'), redAmplitudeReadout = document.getElementById('red-amplitude-readout');
                const redSizeSlider = document.getElementById('red-size'), redSizeReadout = document.getElementById('red-size-readout');
                const redOffsetSlider = document.getElementById('red-offset'), redOffsetReadout = document.getElementById('red-offset-readout');
                const blueAmplitudeSlider = document.getElementById('blue-amplitude'), blueAmplitudeReadout = document.getElementById('blue-amplitude-readout');
                const blueSizeSlider = document.getElementById('blue-size'), blueSizeReadout = document.getElementById('blue-size-readout');
                const blueOffsetSlider = document.getElementById('blue-offset'), blueOffsetReadout = document.getElementById('blue-offset-readout');
                const planeRotX = document.getElementById('plane-rot-x'), planeRotY = document.getElementById('plane-rot-y'), planeRotZ = document.getElementById('plane-rot-z');
                const rotX = document.getElementById('rot-x'), rotY = document.getElementById('rot-y'), rotZ = document.getElementById('rot-z');

                // --- State Variables ---
                let pulseFrequency = 1.0;
                let redFieldState = { amplitude: 4.0, size: 0.8, offset: 0.0 };
                let blueFieldState = { amplitude: 1.3, size: 0.3, offset: 0.0 };
                let planeRotation = { x: 0, y: 0, z: 0 };

                // --- Invisible Filter Plane ---
                const filterPlane = new THREE.Plane(new THREE.Vector3(1, 0, 0), 0);

                // --- Coil and Field Creation ---
                function createBifilarSpiralCoil() {
                    const coilGroup = new THREE.Group();
                    const turns = 12; const maxRadius = 2.0; const wireSeparation = 0.08;
                    const coilMatRed = new THREE.LineBasicMaterial({ color: 0xff0000 });
                    const coilMatBlue = new THREE.LineBasicMaterial({ color: 0x0000ff });
                    const pointsRed = []; const pointsBlue = [];
                    for (let i = 0; i <= turns * 360; i++) {
                        const angle = toRadians(i); const radius = (i / (turns * 360)) * maxRadius;
                        pointsRed.push(new THREE.Vector3(Math.cos(angle) * (radius), 0, Math.sin(angle) * (radius)));
                        const blueAngle = angle + toRadians(wireSeparation / radius * 360 || 0);
                        pointsBlue.push(new THREE.Vector3(Math.cos(blueAngle) * (radius), 0, Math.sin(blueAngle) * (radius)));
                    }
                    coilGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pointsRed), coilMatRed));
                    coilGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pointsBlue), coilMatBlue));
                    return coilGroup;
                }
                masterCoilSystem.add(createBifilarSpiralCoil());

                function createParticleField({ color, particleCount, isRed }) {
                    const particlesGeometry = new THREE.BufferGeometry();
                    const posArray = new Float32Array(particleCount * 3);
                    const metaArray = new Float32Array(particleCount * 2);
                    for (let i = 0; i < particleCount; i++) {
                        metaArray[i * 2] = Math.random() * Math.PI * 2;
                        metaArray[i * 2 + 1] = (0.5 + Math.random() * 0.5) * (Math.random() > 0.5 ? 1 : -1);
                    }
                    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                    particlesGeometry.setAttribute('meta', new THREE.BufferAttribute(metaArray, 2));
                    const particlesMaterial = new THREE.PointsMaterial({ size: 0.08, color: color, transparent: true, opacity: 0.9 });
                    const particleField = new THREE.Points(particlesGeometry, particlesMaterial); // FIX: Define particleField before using it.
                    particleField.userData.isRed = isRed;
                    masterCoilSystem.add(particleField);
                    return particleField;
                }
                
                const redField = createParticleField({ color: 0xff4444, particleCount: 3000, isRed: true });
                const blueField = createParticleField({ color: 0x44aaff, particleCount: 1500, isRed: false });

                // --- Event Listeners ---
                pulseSlider.addEventListener('input', (e) => { pulseFrequency = parseFloat(e.target.value); pulseReadout.textContent = pulseFrequency.toFixed(1); });
                redAmplitudeSlider.addEventListener('input', (e) => { redFieldState.amplitude = parseFloat(e.target.value); redAmplitudeReadout.textContent = redFieldState.amplitude.toFixed(1); });
                redSizeSlider.addEventListener('input', (e) => { redFieldState.size = parseFloat(e.target.value); redSizeReadout.textContent = redFieldState.size.toFixed(1); });
                redOffsetSlider.addEventListener('input', (e) => { redFieldState.offset = parseFloat(e.target.value); redOffsetReadout.textContent = redFieldState.offset.toFixed(1); });
                blueAmplitudeSlider.addEventListener('input', (e) => { blueFieldState.amplitude = parseFloat(e.target.value); blueAmplitudeReadout.textContent = blueFieldState.amplitude.toFixed(1); });
                blueSizeSlider.addEventListener('input', (e) => { blueFieldState.size = parseFloat(e.target.value); blueSizeReadout.textContent = blueFieldState.size.toFixed(1); });
                blueOffsetSlider.addEventListener('input', (e) => { blueFieldState.offset = parseFloat(e.target.value); blueOffsetReadout.textContent = blueFieldState.offset.toFixed(1); });
                
                planeRotX.addEventListener('input', (e) => { planeRotation.x = parseFloat(e.target.value); });
                planeRotY.addEventListener('input', (e) => { planeRotation.y = parseFloat(e.target.value); });
                planeRotZ.addEventListener('input', (e) => { planeRotation.z = parseFloat(e.target.value); });
                
                rotX.addEventListener('input', (e) => masterCoilSystem.rotation.x = toRadians(e.target.value));
                rotY.addEventListener('input', (e) => masterCoilSystem.rotation.y = toRadians(e.target.value));
                rotZ.addEventListener('input', (e) => masterCoilSystem.rotation.z = toRadians(e.target.value));

                // --- Animation Loop ---
                const clock = new THREE.Clock();
                const point = new THREE.Vector3();
                const planeQuaternion = new THREE.Quaternion();
                const euler = new THREE.Euler();

                function updateParticleSystem(particles, state) {
                    const positions = particles.geometry.attributes.position.array;
                    const meta = particles.geometry.attributes.meta.array;
                    const time = clock.getElapsedTime();
                    
                    const { amplitude, size, offset } = state;
                    const isRedField = particles.userData.isRed;
                    
                    for (let i = 0; i < meta.length / 2; i++) {
                        const i2 = i * 2; const i3 = i * 3;
                        const v = meta[i2]; 
                        const u_speed = meta[i2 + 1];
                        const u = time * pulseFrequency * 0.3 * u_speed;
                        
                        const px = (amplitude + size * Math.cos(v)) * Math.cos(u);
                        const py = size * Math.sin(v) + offset;
                        const pz = (amplitude + size * Math.cos(v)) * Math.sin(u);
                        
                        point.set(px, py, pz);
                        
                        const distanceToPlane = filterPlane.distanceToPoint(point);
                        let isVisible = true;
                        
                        if (isRedField && distanceToPlane > 0) isVisible = false;
                        else if (!isRedField && distanceToPlane < 0) isVisible = false;

                        if (isVisible) {
                           positions[i3] = px; positions[i3 + 1] = py; positions[i3 + 2] = pz;
                        } else {
                           positions[i3] = NaN; positions[i3 + 1] = NaN; positions[i3 + 2] = NaN;
                        }
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                }
                
                function updateFilterPlane() {
                    euler.set(toRadians(planeRotation.x), toRadians(planeRotation.y), toRadians(planeRotation.z), 'XYZ');
                    planeQuaternion.setFromEuler(euler);
                    filterPlane.normal.set(1, 0, 0).applyQuaternion(planeQuaternion);
                }

                function animate() {
                    requestAnimationFrame(animate);

                    updateFilterPlane();
                    updateParticleSystem(redField, redFieldState);
                    updateParticleSystem(blueField, blueFieldState);
                    
                    renderer.render(scene, camera);
                }
                
                animate();
            }

            initVisualization();
            document.getElementById('date').textContent = new Date().toLocaleDateString('en-US', {
                year: 'numeric', month: 'long', day: 'numeric' 
            });
        });
    </script>
</body>
</html>
